<!-- TOC -->
* [**Data types in Python**](#data-types-in-python)
* [**Strings**](#strings)
    * [**Задача: Проверка на палиндром**](#задача-проверка-на-палиндром)
* [**Strings literals**](#strings-literals-)
* [**Shielded strings - service characters**](#shielded-strings---service-characters-)
* [**Formatting strings**](#formatting-strings-)
  * [**f-строки мощнее, чем можно было подумать?**](#f-строки-мощнее-чем-можно-было-подумать-)
* [**STR Methods**](#str-methods)
    * [**Задача: Разделение строки**](#задача-разделение-строки)
* [**ord() and chr()**](#ord-and-chr)
    * [**Задача: Замена символов**](#задача-замена-символов)
    * [**Задача: Форматирование имени**](#задача-форматирование-имени)
    * [**Задача: Объединение строк**](#задача-объединение-строк)
    * [**Задача: Проверка на число**](#задача-проверка-на-число)
    * [**Задача: Поиск индекса подстроки**](#задача-поиск-индекса-подстроки)
    * [**Задача: Проверка на уникальность**](#задача-проверка-на-уникальность)
<!-- TOC -->

# **Data types in Python**

В Python, типы данных могут быть **изменяемыми** и **неизменяемыми**.                                 

**Неизменяемые** типы данных означают, что значения, которые хранятся                             
в таких объектах, не могут быть изменены после создания объекта.                                

**Изменяемые** типы данных, напротив, могут изменять значение внутри объекта.                                     


В целом же наши данные в **Python** бывают:                             
* Базовые типы данных(**статические**)                          
* **Коллекции**                        


**К базовым типам данных мы можем отнести:**                           

* **Числовые типы данных**                        
   * `int`: целочисленные значения                      
   * `float`: числа с плавающей точкой (дробные числа)                    
   * `complex`: комплексные числа                    

* **Логический тип данных**                       
   * `bool`: логический тип данных                        

* **Строковый тип данных**                            
   * `str`: строки                            

* **NoneType**                              
   * `None`: тип данных, который указывает на отсутствие значения                              

Каждый из этих типов данных имеет свои собственные операции, которые можно                                 
выполнять с помощью встроенных функций и операторов языка **Python**.                        


```python
# int
int_var = -9

# float
float_var_1 = -14.6
float_var_2 = float(3) # 3.0
float_var_3 = 5. # 5.0
float_var_4 = .7 # 0.7

print(float_var_1, float_var_2, float_var_3, float_var_4)
print(type(float_var_1))
print(type(float_var_2))
print(type(float_var_3))
print(type(float_var_4))
# небольшой подвох с этим типом данных
print(.6 + .6 + .6)
```

# **Strings**

Давайте немного повторим то, что мы с вами знаем о строковом типе данных. Строки в                           
`Python` - упорядоченные последовательности символов, используемые для хранения и                     
представления текстовой информации, поэтому с помощью строк можно работать со всем,                       
что может быть представлено в текстовой форме.                            

Наши с вами строки - **неизменяемый тип данных**, так как это упорядоченные                        
последовательности - каждый символ в строке у нас проиндексирован ( индексация начинается                             
с нуля! ) и идёт по порядку.                            

**Строки мы можем создать следующими путями:**                               

```python
new_string = "my string"
new_string_2 = 'one more string'
new_string_3 = str(12334567890)
new_string_4 = """
super
string
"""

print(new_string, new_string_2, new_string_3, new_string_4, sep="\n")
print(type(new_string), type(new_string_2), type(new_string_3), type(new_string_4), sep="\n")
```


Так же мы можем получать отдельные символы из наших строк,                          
делать по ним срезы, складывать строки, дублировать и ещё                           
много чего. Давайте разбираться.                                     

Так как наши строки являются последовательностью, они имеют индексацию                         
( она начинается с нуля ) мы можем обращаться к этим индексам:                               

```python
new_string = "1q2w3e4r5t6y7u"
print(len(new_string))

print(new_string[6]) # получить конкретный элемент из нашей последовательности

print(new_string[1:4]) # получить срез символов из последовательности

print(new_string[2:6])
```

При работе со срезом есть ещё и третий аргумент ( так сказать ) - шаг.                          
**Шаг** - количество символов, которые мы будем пропускать в нашем срезе:                            

* `[::1]` - каждый первый элемент                        
* `[::2]` - каждый второй элемент                    
* `[::6]` - каждый шестой элемент                        
* `[::10]` - каждый десятый элемент                              

За счёт шага в срезе мы можем выбирать конкретные элементы в нашей строке,                           
не прибегая при этом к циклам ( хотя лучше циклы ). Так же, если мы будем                                      
указывать шаг, который превышает по длине нашу строку - мы просто будем                                  
получать первый элемент:                                           

```python
string = "qwertyqwertyqwerty"          
print(string[::112])                   
```

Так же благодаря шагам мы можем перевернуть нашу строку:

```python
string = "qwerty"
print(string)

print(string[::-1])
```

### **Задача: Проверка на палиндром**

Пользователь вводит строку.
Вывести сообщение, является ли данная строка палиндромом.

---

# **Strings literals**                             

Строки в апострофах и в кавычках - одно и то же. Причина наличия двух                            
вариантов в том, чтобы позволить вставлять в литералы строк символы                                
кавычек или апострофов, не используя экранирование:                         


```python
error_message = "The password field for 'testuser@gmail.com' email is empty"
warn_message = 'No updates for the "Apple INC" profile'
```

# **Shielded strings - service characters**                                   

* `\n` - Перевод строки.
* `\a` - Гудок встроенного в систему динамика.
* `\b` - `Backspace`, он же возврат, он же "пробел назад" – удаляет один символ          
перед курсором. Если `\b` находится в начале строки, то удаления не происходит.
* `\r` - Возврат каретки. Возврат курсора в начало строки.
* `\t` - Горизонтальная табуляция. Горизонтальный отступ слева от начала строки.           
* `\v` - Вертикальная табуляция. Вертикальный отступ сверху            
* `\N{id}` - Идентификатор ID базы данных Юникода          


```python
print('\N{Winking Face}')
```

```python
print("Hello\nWorld\n!\n!\n!")
```

```python
print("Hello World!!", "Hello, World!!!", sep="\b")
```

```python
print("Hello World!", "Hello World!!", "Hello World!!!", sep="\N{Winking Face}")
```


**Ещё есть следующий спец символ:**                                  

* `\newline` - где `newline` продолжение строки                              

```python
sample_of_string = "This is a \
very \
veeeryyy \
veeeeeeeeerrrryyyyyy \
huge string!!!"
```

Относительно последнего спец символа думаю всё достаточно просто. Но выглядит не                               
особо красиво, думаю согласитесь. Для решения такого запроса в `Python`                              
существует так же создание гиперстрок:                                 


```python
hyper_string = """
my
  hyper string
      and message!
"""

print(hyper_string)
```

Такие строки могут облегчить вам жизнь за счёт простоты в использовании и чтении.                                   
Она ничем не будет отличаться от обычной строки, разница лишь в том, что благодаря                                  
такому определению строк мы можем помещать большие текстовые данные, не прибегая                                  
при этом к `\` разделителям при необходимости.                                        

Встречаются такие строки в технической документации к классам, функциям, файлам,                                 
к написанию `SLQ` запросов непосредственно в `Python`, но до этого ещё дойдём.                                     


# **Formatting strings**                          

Думаю мы с вами разобрались уже со строками, тем, как же их нам определять,                                  
какими они могут быть, что у них есть. Но что делать, если мы хотим, чтобы часть                           
строки у нас была более динамичной, чтобы значения в нем могли меняться исходя из                           
каких-то событий?                            

Для такой работы существует как раз наше **форматирование строки**.                              

**Форматирование строк** - это процесс создания строки, содержащей заранее определенные                        
заменители (`placeholders`), которые будут заменены на значения переменных или                           
выражений во время выполнения программы. Форматирование строк является одним из способов                            
создания строк в `Python` и используется для удобства вывода информации в консоли или в файл.                                       

```python
user_name = input()

print("Hello," + " my name is " + user_name)
```

Существуют различные способы форматирования строк. Давайте пройдёмся от давних методов, которые                            
можно встретить до сих пор, хоть и редко, до новых, которыми пользуются по сей день.                                 

1) **Форматирование при помощи знака `%`**                        
ператор `%` используется для замены заранее определенных заменителей на значения                            
переменных или выражений:                              

```python
name = 'Angus'
age = 42
message = "Hello, my name is %s! I'm %d years old." % (name, age)
print(message)
```

В этом примере мы заменяем знак `%s` на строку 'Angus', а знак `%d` на число 42                            
Как нам не запутаться во всех этих знаках?                        

Вот небольшой список возможных значений, которые мы можем подставлять к нашему проценту:                              


* `%d`, `%i`, `%u` - Десятичное число.                  
* `%o` - Число в восьмеричной системе счисления.                    
* `%x` - Число в шестнадцатеричной системе счисления (буквы в нижнем регистре).                    
* `%X` - Число в шестнадцатеричной системе счисления (буквы в верхнем регистре).                         
* `%e` - Число с плавающей точкой с экспонентой (экспонента в нижнем регистре).                     
* `%E` - Число с плавающей точкой с экспонентой (экспонента в верхнем регистре).                        
* `%f`, `%F` - Число с плавающей точкой (обычный формат).                    
* `%g` - Число с плавающей точкой. с экспонентой (экспонента в нижнем регистре),                                    
если она меньше, чем -4 или точности, иначе обычный формат.                           
* `%G` - Число с плавающей точкой. с экспонентой (экспонента в верхнем регистре),                    
если она меньше, чем -4 или точности, иначе обычный формат.                       
* `%c` - Символ (строка из одного символа или число - код символа).                      
* `%r` - Строка (литерал python).                        
* `%s` - Строка (как обычно воспринимается пользователем).                       
* `%%` - Знак %.                               

Этот способ форматирования достаточно стар и мало где используется, хоть и используется.                              
Если где-то встретите символы процента в строке - не пугайтесь и не думайте,                                    
что же это такое. Вы будете уже с этим знакомы.                              

2) **Форматирование строк при помощи метода `.format()`**                            

Этот метод является более новым и используется до сих пор. Достаточно практичный,                               
хороший и удобный метод для работы с динамичными значениями в строках.                        

Часто используется при работе с какими-нибудь готовыми текстовыми шаблонами, в                              
которые необходимо подставлять нужные значения только в определённые места                               
( шаблонные письма для рассылок и т.д )                     

Давайте разбираться на практике                         

```python
dynamic_value = input()

print("Hello, {}".format(dynamic_value))
```

Мы так же можем передавать и несколько аргументов подряд, если необходимо:                             


```python
dynamic_name = input()
dynamic_age = int(input())

print("Hi! My name is {}, I'm {} y.o.".format(dynamic_name, dynamic_age))
```

Каков принцип работы нашего метода, если у нас несколько аргументов на вход?                         
Если у нас фигурных скобок в шаблоновой строке больше, чем аргументов и мы не                            
задавали никаких последовательностей - у нас будет ошибка, так как наш `Python`                      
будет пытаться найти аргументы, которых нет.                        

При этом же, если у нас самих аргументов больше, чем наших фигурных скобок,                             
при этом мы ничего не указывали в последовательности подставления, то `Python`                                  
будет брать наши аргументы по порядку для подставления, а всё, что останется                                
вне наших фигурных скобок - просто проигнорируется.                               

Давайте разбираться:

```python
a = "Some string {} {} {} {}"

b = "One more string {} {}"

print(a.format("arg_1", "arg_2", "arg_3", "arg_4"))

print(a.format("arg_1", "arg_2", "arg_3")) # Будет ошибка, так как нам не достаёт одного аргумента для нашего шаблона

print(b.format("arg_1", "arg_2", "arg_3")) # Ошибки не будет, наш третий аргумент пропустится
```

Так же мы можем сами определять очерёдность наших аргументов:                                       


```python
a = "{1} {0} {1}"

print(a.format("arg_1", "arg_2"))
```

Если мы сами определяем очерёдность наших аргументов, то в таком случае в целом мы можем                               
( в теории ) указать аргументов меньше, чем их должно быть в шаблоне:                                      

```python
b = "{0}-{1}-{0}"

print(b.format("abra", "kad"))
```

Если вдруг кому-то неудобно идти по индексам при определении последовательности наших                                   
аргументов - мы можем делать это через имена переменных:                          


```python
name = input("ENter your name: ")
age = input("ENter your age: ")

a = "Hi! My name is {name}, I'm {age} y.o."

print(a.format(name, age))
# print(a.format(name="Viktor", age=25))
```

3) **Форматирование строки через символ `f`**                         

Последний и актуальный, достаточно частый в использовании способ сделать нашу строку                                       
более гибкой - создание `f-строки`. Каков синтаксис:                                

```python
page_site = "VK"
status_code = 500
message = f"Can't loading '{page_site}' page. Unsecure connection."

error_message = f"Error. \nStatus code: {status_code}, \nError message: {message}"
```

## **f-строки мощнее, чем можно было подумать?**                       

`f-строки` обладают кое-какими полезными возможностями, некоторыми особенностями, о                   
которых кто-нибудь может и не знать. Разберёмся с некоторыми интересными                         
возможностями `f-строк`, которые могут оказаться очень кстати в повседневной                              
работе Python-программиста.                           

Функционал `f-строк` сравнительно недавно (начиная с `Python 3.8`) дополнен                                    
возможностями по выводу имён переменных вместе с их значениями:                           

```python
x = 10
y = 25
print(f"x = {x}, y = {y}")
# x = 10, y = 25
print(f"{x = }, {y = }")  # Лучше! (3.8+)
# x = 10, y = 25

print(f"{x = :.3f}")
# x = 10.000
```

`F-строки` поддерживают [мини-язык спецификаций форматирования](https://docs.python.org/3/library/string.html#formatspec) `Python`. Поэтому в                             
модификаторы, используемые в `f-строках`, можно внедрить множество                               
операций форматирования данных:                                        

```python
text = "hello world"

# Центрирование текста:
print(f"{text:^15}")
# '  hello world  '

number = 1234567890
# Установка разделителя групп разрядов
print(f"{number:,}")
# 1,234,567,890

number = 123
# Добавление начальных нулей
print(f"{number:08}")
# 00000123
```

---

# **STR Methods**

У строк, как и у всех типов данных из разряда коллекций, есть свои методы.            
Давайте пройдёмся по самым распространённым из них.

* **Метод len()**
Он относится не конкретно к строкам, а скорее ко всем коллекциям. Этот            
метод просто возвращает нам длинну того, что мы поместим в него(в основном из коллекций).

* **Методы `lower()` и `upper()`**                              

Очень похожи друг на друга методы, которые предназначены для конвертации символов строки в          
верхний, или нижний регистр.

Могут пригодиться, когда вы сравниваете строковые данные и не уверены, что в них          
используется только нижний, или верхний регистр. Этими методами вы можете привести всё          
к одному единому формату.

```python
lower_string = "some string value in lower case"
print(lower_string.upper())
print(lower_string)

upper_string = "ANSJDKANSD AJSNDKAJSDUIQWE QWELQWE"
print(upper_string.lower())
```

Самые распространённые места применения таких методов на моей практике - моменты, когда                     
вам нужно проверить имя пользователя. Некоторые могут вводить свои имена и фамилии с                              
маленькой буквы, а некоторые с большой.                         

* **метод strip()** - Ещё один интересный и полезный моментами метод                                           

Предназначен для удаления пробельных символов в начале и в конце строки. Так же зачастую                              
используется при проверках имени пользователя.                     

```python
user_name = " Mark zukerberg "
print(len(user_name))

updated_name = user_name.lower().strip()
print(updated_name)
print(len(updated_name))
```
* **Метод split()**                        
Один из наиболее используемых в программировании. Этот метод может разделить строку                            
на список подстрок на основе заданного разделителя (по умолчанию - пробел).                      

```python
my_string = "Hello, World! We're using Python!"

converted_string = my_string.split()
print(converted_string)
converted_string_2 = my_string.split(",")
print(converted_string_2)
converted_string_3 = my_string.split("e")
print(converted_string_3)
```


### **Задача: Разделение строки**

Пользователь вводит строку, содержащую имена, разделенные запятыми.
Разделить строку на список имен.
Вывести список имен.


* **join()**                           
принимает в себя список со строками и конвертирует их в одну строку с                             
использованием заданного разделителя.                           

```python
list_of_strings = ["We're", "learn", "Python", "language."]
print(", ".join(list_of_strings))
```

```python
employes_list = ["Mark", "Isabel", "Daniel", "Irina", "Margaret"]

message_template = f"""
  Dear {', '.join(employes_list)}
  You're fired.
"""
print(message_template)
```

* **Метод replace()**                          
Этот метод принимает в себя два аргумента: подстроку, которую вы хотите                                
заменить и подстроку, НА которую вы хотите заменить. Чтобы не было путаницы в                                   
теории, давайте разбираться на практике:                             

```python
string_1 = "Hi! I'm using Java!"
print(string_1.replace("Java!", "Python!"))
print(string_1)
```

# **ord() and chr()**

Так же в Питоне есть встроенные методы, которые позволяют нам работать                        
со строками в контексте преобразования символов в числа(ID этих символов)                       

Функция `ord()` в Python принимает строковый аргумент из одного символа                          
`Unicode` и возвращает его целочисленное значение кодовой точки                        

```python
x = ord('A')
print(x)
print(ord('ć'))
print(ord('ç'))
print(ord('$'))
```

Функция `chr()` в Python принимает целочисленный аргумент и возвращает строку,                         
представляющую символ в этой кодовой точке                                    

```python
y = chr(65)
print(y)
print(chr(123))
print(chr(36))
```

Поскольку функция `chr()` принимает целочисленный аргумент и преобразует                          
его в символ, существует допустимый диапазон для ввода.                            

Допустимый диапазон для аргумента – от `0` до `1114111` (0x10FFFF в                              
шестнадцатеричном формате). Если входное целое число находится за пределами                               
этого диапазона, будет вызвано исключение `ValueError`                         


```python
print(chr(-1))
# ->> ValueError: chr() arg not in range(0x110000)
```

---

### **Задача: Замена символов**

Пользователь вводит строку.
Заменить все вхождения одного символа в строке на другой символ.
Вывести измененную строку.

Ещё некоторые методы, которые могут встречаться, или понабодиться:                             

* `isalnum()` - проверяет, состоит ли строка только из букв и цифр                           
* `isalpha()` - проверяет, все ли символы в строке - часть алфавита.                           
Возвращает `bool` значение.                       
* `isdigit()` - проверяет, состоит ли строка только из цифр. Учитывает                         
так же Юникод цифры. Возвращает `bool` значение.                          
* `title()` - преобразовывает строку таким образом, чтобы первая буква                                 
каждого слова была заглавной.                       
* `capitalize()` - преобразовывает строку таким образом, что первая подстрока                                   
будет начинаться с заглавной буквы.                              
* `isascii()` - содержит ли строка только символы `ASCII` (**American Standard                       
Code for Information Interchange**). `ASCII` — это стандартный набор символов,                           
который включает в себя буквы английского алфавита (прописные и строчные),                              
цифры, знаки пунктуации и некоторые специальные символы.                             
* `encode()` - используется для преобразования строки в последовательность байтов,                                      
используя определенное кодирование (`encoding`). Кодирование определяет, как                                        
символы будут представлены в виде байтовых значений.                             


Метод `encode()` полезен, когда требуется преобразовать строку в байтовую последовательность                                        
для передачи или сохранения данных, особенно при работе с сетевыми протоколами или файлами.                                         
Необходимо убедиться, что используемое кодирование соответствует ожиданиям и типу данных,                                       
с которыми идёт работа.                             

### **Задача: Форматирование имени**

Пользователь вводит свое имя.

Преобразовать первую букву имени в верхний регистр и остальные       
буквы в нижний регистр. Учесть возможные пробелы в начале и конце имени

Вывести отформатированное имя.


### **Задача: Объединение строк**

Пользователь вводит две строки.                             
Объедините строки в одну, добавив пробел между ними.(всеми возможными способами)                             
Вывести объединенную строку.                             


### **Задача: Проверка на число**

Пользователь вводит строку.                                                          
Проверить, является ли введенное значение числовым.                             
Вывести сообщение о результате проверки.                             


### **Задача: Поиск индекса подстроки**

Пользователь вводит строку и подстроку.                             
Найти индекс первого вхождения подстроки в строку.                             
Вывести индекс или сообщение, если подстрока не найдена.                             
