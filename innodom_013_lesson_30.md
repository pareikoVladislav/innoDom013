<!-- TOC -->
* [**Django Rest Framework**](#django-rest-framework)
* [**REST API**](#rest-api)
* [**DRF (Django Rest Framework)**](#drf-django-rest-framework)
* [**What is DRF and why is it needed?**](#what-is-drf-and-why-is-it-needed)
* [**Main advantages of DRF**](#main-advantages-of-drf)
* [**DRF Installation and Settings**](#drf-installation-and-settings)
* [**Main features of DRF serializers**](#main-features-of-drf-serializers)
* [**Types of serializers**](#types-of-serializers)
* [**ModelSerializer**](#modelserializer)
* [**Serializer**](#serializer)
* [**Методы сериализаторов**](#методы-сериализаторов)
<!-- TOC -->

# **Django Rest Framework**

# **REST API**

**REST API (Representational State Transfer Application Programming Interface)** -                                               
это стиль архитектуры программного обеспечения, который определяет                                                              
правила и соглашения для построения веб-сервисов.                                                                         

**REST API** позволяет взаимодействовать с веб-приложениями и           
сервисами с использованием стандартных `HTTP` методов, таких          
как `GET`, `POST`, `PUT`, `DELETE` и других.            


Все элементы в `REST API` представляются в виде ресурсов, которые                                        
могут быть, например, **объектами**, **БД**, **файлами** или любыми другими                                                  
сущностями. Каждый ресурс имеет уникальный идентификатор (`URI`), по                                                     
которому к нему можно обращаться.                                                             


Ресурсы предоставляются в различных форматах представления данных,                                                                        
таких как `JSON`, `XML`, `HTML`, и др. Клиент может запросить конкретное                                                                       
представление, указав заголовок `Accept` с нужным типом данных.                                                                          
Мы в основном(пока что) будем работать именно с `JSON`                                                             

Каждый запрос к серверу в `REST API` содержит всю необходимую                                                                                         
информацию для его обработки. Сервер **не хранит** состояние клиента                                                                                      
между запросами. Т.е. каждый запрос должен содержать всю необходимую                                                                                     
информацию для выполнения операции                                                                                         


`REST API` обычно имеет много различных `endpoints` для разных типов                                                                                            
ресурсов и операций. Все эти `endpoints` совместно образуют интерфейс                                                                                           
`API`, через который клиенты могут взаимодействовать с сервером и                                                                                         
выполнять различные задачи и операции.                                                                        

---

# **DRF (Django Rest Framework)**

Это мощный инструмент, разработанный для создания `веб-API` на                                                                         
основе фреймворка `Django`.                                                                                       
Он предоставляет набор инструментов и функций, упрощающих                                                                         
разработку `API`, а также обеспечивает множество возможностей для                                                                         
управления данными, авторизации, аутентификации и многого другого.                                                                        

# **What is DRF and why is it needed?**

**Django Rest Framework (DRF)** - это библиотека `Python`,                                                                                        
предназначенная для создания `веб-API` с использованием фреймворка                                                                                        
`Django`. Она обеспечивает инструменты для преобразования данных                                                                                       
модели `Django` в `JSON` или другие форматы, которые могут быть                                                                                        
использованы для обмена данными с другими приложениями,                                                                                        
веб-сервисами или фронтенд-клиентами.                                                                                       

**Зачем нужен DRF?**

* **Разработка API**: `DRF` упрощает разработку `API`, позволяя                                                                                        
разработчикам создавать мощные и гибкие точки входа для                                                                                       
работы с данными приложения.                                                                                                            


* **Управление данными**: Он предоставляет инструменты для                                                                                       
**создания**, **обновления**, **удаления** и **извлечения данных** из базы                                                                                        
данных, используя `HTTP-запросы` и **методы**.                                                                                                      


* **Аутентификация и авторизация**: `DRF` обеспечивает встроенную                                                                                        
поддержку аутентификации и авторизации, что делает его идеальным                                                                                       
выбором для создания безопасных `API`.                                                                                                    


* **Сериализация**: `DRF` позволяет автоматически преобразовывать                                                                                       
данные модели `Django` в формат `JSON` или другие форматы, что                                                                                        
упрощает обмен данными между клиентом и сервером.                                                                                                        


* **Поддержка разных форматов**: Он поддерживает различные форматы                                                                                       
данных, включая `JSON`, `XML` и другие, что позволяет вам выбрать                                                                                        
наиболее подходящий формат для вашего `API`.                                                                                                     

---

# **Main advantages of DRF**

* **Простота использования**: `DRF` предоставляет простой и интуитивно                                                                          
понятный способ создания `API`, что упрощает работу разработчиков.                                                                          


* **Мощные возможности**: Он предоставляет множество функций, таких                                                                           
как **автоматическая документация** `API`, **обработка ошибок**, **фильтрация**,                                                                          
**сортировка** и многое другое.                                                                                       


* **Гибкость**: `DRF` позволяет настраивать `API` в соответствии с                                                                           
требованиями вашего проекта и легко расширять его функциональность.                                                                          


* **Безопасность**: Благодаря встроенной поддержке аутентификации и                                                                           
авторизации, `DRF` обеспечивает безопасность ваших `API`.                                                                          


* **Активное сообщество**: `DRF` имеет большое и активное сообщество                                                                           
разработчиков, что означает, что вы можете легко найти решения для                                                                           
ваших проблем и получить поддержку                                                                                       


---

# **DRF Installation and Settings**

Для начала работы с `Django Rest Framework`, установим его в вашем                                                                                      
виртуальном окружении с помощью пакетного манагера `pip`:                                                                          

```commandline
pip install djangorestframework
```

ДОбавим `rest_framework` в `INSTALLED_APPS` в файле                                                                          
`settings.py` нашего `todoapp` проекта:                                                                                     

```python
INSTALLED_APPS = [
    # ...
    'rest_framework',
    # ...
]
```

И так же можем добавить настройки для прохода запросов. Любой не                                                           
авторизированный юзер сможет только смотреть данные, но не создавать\                                                    
обновлять\удалять:                                                                

```python
REST_FRAMEWORK = {
    "DEFAULT_SCHEMA_CLASS": "rest_framework.schemas.coreapi.AutoSchema",
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.IsAuthenticated",
    ],
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework.authentication.BasicAuthentication",
        "rest_framework.authentication.SessionAuthentication",
    ],
    "DATETIME_FORMAT": "%Y-%m-%d %H:%M:%S",
    "DATE_FORMAT": "%Y-%m-%d",
}
```

**Что нового даёт DRF?**

По сути у нас будет два основных изменения в работе:               

1) Полностью новые `views` методы                                                                        
2) Вместо `forms` у нас будут специальные классы-сериализаторы,                                                      
которые будут наши данные валидировать и сереализовать или в `JSON`                                                         
или же из него в объекты питона.                                                               

Сериализаторы мы создаём в файлике `serializers.py`. По умолчанию                                                            
его нет, нам нужно будет создать его самим в приложении.                                                                    

# **Main features of DRF serializers**

* Сериализаторы определяют, какие поля модели должны быть включены                                                                          
в ответ `API`. Они преобразуют модель или другой тип данных в словарь                                                                          
`Python`, который затем может быть преобразован в нужный формат,                                                                           
например, в `JSON`                                                                          

* Выполняют **десериализацию данных**, преобразуя данные, полученные от                                                                                
клиента (например, `JSON`), обратно в объекты `Python`, которые могут                                                                                    
быть сохранены в базу данных или использованы в приложении.                                                                          

* Предоставляют встроенные механизмы для валидации                                                                           
данных. Они проверяют, что данные соответствуют ожидаемому                                                                          
формату и типу, а также выполняют другие проверки, чтобы обеспечить                                                                         
правильность данных                                                                         

* Позволяют работать с вложенными и связанными объектами, например, если                                                                            
у модели есть `ForeignKey` или `ManyToManyField`. Они могут автоматически                                                                                
сериализовать и десериализовать связанные объекты                                                               


* Также используются при создании и обновлении данных через `API`. Они могут                                                                           
автоматически обрабатывать данные, полученные от клиента, и создавать                                                                           
или обновлять связанные объекты                                                               


# **Types of serializers**

* **ModelSerializer** - наиболее распространенный и удобный тип                                                                               
сериализатора в `DRF`. Он **автоматически** создаёт сериализатор на основе                                                                               
модели `Django`, что упрощает создание сериализатора для моделей.                                                                                
Также обеспечивает автоматическую обработку связанных объектов                                                                              


* **Serializer** - базовый класс для создания пользовательских                                                                               
сериализаторов. Позволяет явно определить каждое поле, которое                                                                                
нужно сериализовать или десериализовать. Предоставляет более гибкий                                                                               
контроль над форматом данных                                                                                  


* **JSONSerializer** - сериализатор для работы с данными в формате `JSON`.                                                                            
Он предоставляет функциональность для сериализации и                                                                               
десериализации данных в `JSON`                                                                             


* **FormSerializer** - позволяет использовать Django формы в качестве                                                                              
сериализаторов для работы с данными, подобно Django формам                                                                            


* **BaseSerializer** - базовый класс для всех сериализаторов в DRF. Он                                                                               
определяет общие методы и функциональность, которые наследуются                                                                           
другими видами сериализаторов                                                                             


---

# **ModelSerializer**

**ModelSerializer** в DRF является специальным типом сериализатора,                                                                              
который предоставляет удобные и автоматические средства для работы с                                                                              
моделями Django.                                                                           
Он упрощает создание сериализаторов, автоматически определяя набор                                                     
полей и создавая реализации по умолчанию для методов                                                                   
`create()` и `update()`.                                                                                

Этот сериализатор позволяет легко создавать `API` на основе моделей                                                                            
`Django`, обеспечивая автоматическую обработку полей модели, валидацию                                                                           
данных и связанных объектов.                                                                              

**Он:**                                                               

1) автоматически определяет поля сериализации на основе модели `Django`,                                                                             
которая указывается в атрибуте `Meta.model` сериализатора. Это позволяет                                                                            
упростить определение полей, которые должны быть сериализованы или десериализованы.                                                                                  

2) автоматически обрабатывает связанные объекты (например, `ForeignKey` или                                                                                   
`ManyToManyField`) и включает их данные в ответ `API`. Это позволяет удобно                                                                                
работать с связанными данными без дополнительных усилий                                                               

3) предоставляет встроенные механизмы валидации данных, что позволяет                                                                              
автоматически проверять правильность введенных данных перед сохранением модели в БД.                                                                              

4) умеет автоматически обновлять данные модели при десериализации запросов `PUT`                                                                               
или `PATCH`, что делает процесс обновления объектов более простым и удобным.                                                                               

5) позволяет использовать другие сериализаторы в качестве полей, что позволяет                                                                                       
обрабатывать вложенные объекты и создавать сложные структуры данных в ответах API.                                                                                     


# **Serializer**

**Serializer** в DRF является базовым классом для создания                                                                
пользовательских сериализаторов.                                                                                 
Является более низкоуровневым и требует большего количества                                                                                  
ручной настройки. Это хорошо для более сложных сценариев,                                                                                  
где требуется полный контроль.                                                                                 

Он предоставляет более гибкий контроль над процессом сериализации и                                                                                 
десериализации данных, чем `ModelSerializer`, позволяя явно определить                                                                             
каждое поле, которое нужно сериализовать или десериализовать                                                                                 


**Он:**

1) При использовании `Serializer`, разработчик должен явно определить                                                                                 
каждое поле, которое будет сериализовано или десериализовано. Это                                                                               
делает контроль над форматом данных более точным и позволяет легко                                                                              
добавлять или исключать поля по необходимости.                                                                                

2) позволяет определять пользовательские методы (custom methods) для обработки                                                                              
данных или выполнения дополнительных операций при сериализации или                                                                           
десериализации. Это позволяет добавить логику, которая не связана                                                                                     
напрямую с полями модели.                                                               

3) предоставляет встроенные механизмы валидации данных, что позволяет проверять                                                                                  
правильность введенных данных перед их обработкой или сохранением                                                                                 

4) предоставляет возможность явно указать, как обрабатывать связанные объекты, такие                                                                                 
как `ForeignKey` или `ManyToManyField`. Это позволяет легко определять, какие поля                                                                              
связанных объектов должны быть включены в ответ `API`                                                               

5) позволяет использовать другие сериализаторы в качестве полей, что позволяет                                                                                 
обрабатывать вложенные объекты и создавать сложные структуры данных в ответах API                                                                                   


# **Методы сериализаторов**

* `create(self, validated_data)` - вызывается при десериализации данных для                                                                                 
создания нового объекта на основе переданных данных `validated_data`.                                                                               
Вам следует переопределить этот метод, если хотите выполнить                                                                              
дополнительные действия при создании объекта, например, установить                                                                                
значения для некоторых полей перед сохранением объекта                                                                                   

* `update(self, instance, validated_data)` - вызывается при десериализации                                                                            
данных для обновления существующего объекта `instance` на основе                                                                               
переданных данных `validated_data`. Вы должны переопределить этот метод,                                                                               
если хотите выполнить дополнительные действия при обновлении объекта.                                                                               

* `validate_<field_name>(self, value)` - можно определить методы валидации                                                                             
для каждого поля, указав имя поля в формате `validate_<field_name>`.                                                                                   
Например, для поля `title`, метод валидации будет называться `validate_title`. В                                                                                
этом методе вы можете проверить значение поля и вызвать исключение                                                                                
`serializers.ValidationError`, если данные недопустимы.                                                                                  

* `validate(self, data)` - позволяет проводить общую валидацию данных. В                                                                               
этом методе вы можете проверить связанные поля или выполнить                                                                                 
другие проверки, которые требуют взаимодействия между несколькими                                                                              
полями                                                                                 

* `to_representation(self, instance)` - вызывается при сериализации объекта                                                                               
`instance` для преобразования его данных в формат, который будет                                                                                
возвращен в ответе `API`. Вы можете переопределить этот метод, чтобы                                                                                                                                               
настроить формат вывода данных                                                                                 

* `to_internal_value(self, data)` - вызывается при десериализации данных для                                                                                  
преобразования данных из запроса во внутренний формат, который                                                                                  
будет использован для создания или обновления объекта                                                                                  

* `run_validation(self, data)` - вызывается в процессе валидации данных для                                                                               
проверки их правильности. Вы можете переопределить этот метод, если                                                                                  
хотите кастомизировать процесс валидации.                                                                                  

* `get_<field_name>(self, instance)`: можно определить методы получения                                                                                 
данных для каждого поля, указав имя поля в формате `get_<field_name>`.                                                                               
Например, для поля `title`, метод будет называться `get_title`. В этом методе                                                                                 
вы можете вернуть измененное или дополнительное значение поля при                                                                               
сериализации                                                               
---


**Сериализаторы работают достаточно по простому алгоритму:**                                                               

Они "кушают" наши модели, которые мы им укажем, и выдают на                                                                
выходе красивый `JSON`                                                                               

Создадим в проекте новое приложение `api`:

```commandline
cd apps/
python ../manage.py startapp api
```

Не забываем зарегистрировать новое приложение в настройках проекта!            

И далее как раз создадим в этом приложении файл `serializers.py`

```python
from rest_framework import serializers

from apps.tasks.models import Task


class TaskSerializer(serializers.ModelSerializer):
    class Meta:
        model = Task
        fields = [
            'title',
            'description',
            'category',
            'status',
            'creator',
            'date_started',
            'deadline',
            'updated_at',
        ]

```

**Что у нас тут происходит:**                                                                  

1) Мы импортируем сюда специальный файл сериализаторов                                                                   
из нашей новой библиотеки                                                                              
2) Дальше импортируем нужную нам модель для будущей                                                                   
работы с ней                                                                                 
3) Определяем наш класс-сериализатор, который наследуется                                                                   
от сериализатора моделей                                                                            
4) Внутри прописываем Мета-класс, в котором определяем                                                                  
для какой модели будет происходить сериализация, и по каким полям                                                                  

**Можем посмотреть с вам как это выглядит в консоли:**                                                                           

```commandline
python manage.py shell
```

```commandline
from apps.api.serializers import TaskSerializer
from apps.todo.models import Task

tasks = Task.objects.all()

ser = TaskSerializer(tasks, many=True)
ser.data
```

Наша задача, как бэков в ВЭБ разработке достаточно проста:                                                                            
Мы будем заниматься разработкой подобных вот механизмов, чтобы                                                               
по определённым запросам от фронта предоставлять данные в нужном                                                         
формате, обрабатывать и записывать данные в БД, принятые от                                                     
клиента, заниматься валидацией. Всё, что может быть связано с                                                       
**frontend** частью (отображение красивое, стили и прочее) - не трогаем.                                                       


Модели у нас есть, сериализатор один есть, давайте напишем **функцию-отображение**                                                       
для всего этого дела и посмотрим как же будут выглядить наши будущие `API`:                                                       


У нас будет функция, в которой будет содержаться код для двух сценариев:                                               
1) Что должно быть, если нам пришёл `GET` запрос                                                            
2) Что должно быть, если нам пришёл `POST` запрос                                                          

Сама же функция будет покрыта двумя декораторами (Один позволит нам                                                      
добавить возможность того, что эта функция будет вызываться только                                                            
на определённые, указанные нами же `HTTP` методы. Второй же позволит нам                                                    
ограничить функционал от всех не зарегестрированных личностей.)                                                           

```python
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework.request import Request
from rest_framework import status

from apps.tasks.models import Task
from apps.tasks.serializers import TaskSerializer


@api_view(['GET', 'POST'])
def task_list(request: Request):
    if request.method == 'POST':
        serializer = TaskSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()

            return Response(
                status=status.HTTP_201_CREATED,
                data=serializer.data
            )

        return Response(
            status=status.HTTP_400_BAD_REQUEST,
            data=serializer.errors
        )
    else:
        tasks = Task.objects.all()
        if tasks:
            serializer = TaskSerializer(instance=tasks, many=True)

            return Response(
                status=status.HTTP_200_OK,
                data=serializer.data
            )
        return Response(
            status=status.HTTP_204_NO_CONTENT,
            data=[]
        )

```

Так же для всего этого дела у нас с вами будут написаны `url`, которые будут                                                  
строго для `API`. Для этого создадим новое ответвление в файле `urls.py`                                                 

```python
#config.urls
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path("admin/", admin.site.urls),
    path("api/v1/", include('apps.router')),
]
```
роутер:

```python
from django.urls import path, include


urlpatterns = [
    path("tasks/", include('apps.tasks.urls')),
]
```

И конкретно наш, только для `api` файл эндпоинтов:                                              

```python
from django.urls import path

from apps.tasks.views import task_list

urlpatterns = [
    path("", task_list),
]
```

Попробуем добавить новую запись:

```json
{
    "title": "NEW DRF TASK",
    "description": "THIS IS OUR FIRST TEST TASK FROM THE DJANGO REST FRAMEWORK API",
    "category": 1,
    "status": 2,
    "creator": 1,
    "deadline": "2024-01-10T18:25:00.689533Z",
    "deadline": "2024-01-16T00:00:00.689533Z"
}
```

Но такой подход написания функций-отображение особо не применяется                                                                        
сейчас в разработке. Во всяком случае достаточно редко, точечно.                                                                         

**Django** - фреймворк более **ООП-ориентированный**, поэтому и написание                                                                         
функционала там идёт обычно через **создание классов**, **переопределение**,                                                                        
**переиспользование**, **наследование** и т.д.                                                                        

**Существует ТРИ вида классов-отображений**:

* Низкоуровневый(`APIView`)
* Среднеуровневый(`GenericView`)
* Высокоуровневый(`ModelViewSet`)

Чем более высокоуровневый эндпоинт, тем меньше вам нужно будет дополнительно                                                       
прописывать.                                                                         

В разработке существует такое понятие, как `CRUD`. Своего рода                                                     
инструкции по созданию методов для различных сущностей, позволяющих                                                        
связывать приложение с сервером.                                                                    

* `C` - Create **(post)**
* `R` - Read **(get)**
* `U` - Update **(put, patch)**
* `D` - Delete **(delete)**

```python
# api.views.py
from rest_framework.views import APIView, Response, Request
from rest_framework.exceptions import ValidationError
from rest_framework import status

from apps.tasks.models import Task
from apps.tasks.serializers import TaskSerializer


class TasksApiView(APIView):
    def get(self, request: Request):
        tasks = Task.objects.filter(creator=request.user.id)

        if tasks:

            serializer = TaskSerializer(instance=tasks, many=True)

            return Response(
                status=status.HTTP_200_OK,
                data=serializer.data
            )

        return Response(
            status=status.HTTP_204_NO_CONTENT,
            data=[]
        )

    def post(self, request: Request):
        try:
            serializer = TaskSerializer(
                data=request.data
            )
            serializer.is_valid(raise_exception=True)
            serializer.save()

            return Response(
                status=status.HTTP_201_CREATED,
                data=serializer.data
            )
        except ValidationError as error:
            return Response(
                status=status.HTTP_400_BAD_REQUEST,
                data={
                    "error": str(error),
                    "detail": error.detail
                }
            )
```

И дальше в нашем приложении `api` мы создадим эндпоинт для нашего класса:

```python
urlpatterns = [
    path("tasks/", TasksApiView.as_view()),
]

```

Как вы могли заметить, мы вторым аргументом передаём название нашего                                                   
класса и после вызываем там спец метод `as_view()`, который поможет                                                        
нашей системе воспринимать этот класс, как отображение.                                                         


Более высокоуровневые же классы могут выглядеть следующим образом:                                                       

`GenericView`:                                                    

```python
class TaskInfoGenericView(RetrieveAPIView):
    serializer_class = TaskSerializer

    def get_object(self):
        task_id = self.kwargs.get("task_id")

        task = get_object_or_404(Task, id=task_id)

        return task
```

Как видите, писать нужно в разы меньше. И да, это далеко не показатель на                                                  
самом деле, ведь задачи всегда различаются и что-то можно написать достаточно                                                 
кратко, что-то растягивается. ЧТо-то нужно\можно использовать, что-то нет.                                                     
КОнкретно в этом примере мы написали класс-отображение, который отвечает строго                                               
за отображение конкретной задачи по её уникальному ID.                                                                  
Так как это более высокоуровневый класс, нам с вами будет достаточно определить                                                
классы-ограничители(кто может "пробивать") этот запрос. И так же класс-сериализатор,                                              
отвечающий за сереализацию данных.                                                                      

Для того, чтобы получить конкретный объект по его `ID` мы можем воспользоваться                                             
переопределением метода `get_object()`. В него(в нашем случае) мы ничего не                                                  
передаём. Логика внутри же крайне проста: получаем `ID` из `request` параметров,                                                   
получаем инстанс определённой задачи по этому `ID`                                                            

Мы так же вполне можем переписать и эту логику, если нас не устраивает такой                                               
результат, мы хотим что-то добавить, или же возвращать данные в другом                                                   
формате.

```python
class TaskInfoGenericView(RetrieveUpdateAPIView):
    serializer_class = TaskSerializer

    def get_object(self):
        task_id = self.kwargs.get("task_id")
        task = get_object_or_404(Task, id=task_id)

        return task

    def get(self, request: Request, *args, **kwargs):
        task = self.get_object()

        serializer = self.serializer_class(task)

        return Response(
            status=status.HTTP_200_OK,
            data=serializer.data
        )

    def put(self, request, *args, **kwargs):
        task = self.get_object()

        serializer = self.serializer_class(task, data=request.data)

        if serializer.is_valid(raise_exception=True):
            serializer.save()

            return Response(
                status=status.HTTP_201_CREATED,
                data=serializer.data
            )

        return Response(
            status=status.HTTP_400_BAD_REQUEST,
            data=serializer.errors
        )
```

Обычные функции, а так же классы `APIView` и `GenericView` возвращают                                                       
обычно ровно один эндпоинт. Для отображения списка всех задач - свой                                                         
класс, для обновления - свой, для удаления - свой. Всё разбито.                                                          

НО есть так же и самый из высокоуровневых классов-родителей для наследования                                                
и это - класс `ModelViewSet`. ОН считается самым высокоуровневым из                                                      
существующих. Говорю сразу - встречать его вы будете крайне редко. Так как обычно                                               
вам нужно будет больше свободы действий для чего0то кастомного. НО иногда                                                
всё же он применяется. ЛОгика написания крайне простая


```python
class StatusViewSet(ModelViewSet):

    queryset = Status.objects.all()
    serializer_class = StatusSerializer
```

```python
class CategoryViewSet(ModelViewSet):

    queryset = Category.objects.all()
    serializer_class = CategorySerializer
```

Здесь нам важно определять `queryset` данных, с которыми этот класс                                                       
будет работать. `queryset` - набор данных. ПРедставлен обычно в виде                                                         
списка с уникальными значениями, где значение - объект класса.                                                             

Помимо `queryset` мы так же указываем класс для сериализации данных:                                                     

```python
from rest_framework import serializers

from apps.categories.models import Category


class CategorySerializer(serializers.ModelSerializer):
    class Meta:
        model = Category
        fields = '__all__'

    def validate_name(self, value):
        if len(value) < 3:
            raise serializers.ValidationError("Название категории не может быть меньше 4 символов")

        if len(value) > 25:
            raise serializers.ValidationError("Название категории должно быть меньше 25 символов")

        return value

```

```python
from rest_framework import serializers

from apps.statuses.models import Status


class StatusSerializer(serializers.ModelSerializer):
    class Meta:
        model = Status
        fields = '__all__'

    def validate_name(self, value):
        if len(value) < 3:
            raise serializers.ValidationError("Название статуса не может быть меньше 3 символов")

        if len(value) > 25:
            raise serializers.ValidationError("Название статуса должно быть меньше 25 символов")

        return value

```

Как вы можете тут увидеть, помимо валидации всех полей (там их всего 2)                                                  
мы так же можем дописывать и свои персональные валидаторы, которые вполне                                                   
успешно будут работать на нас. Разновидностей много, мы рассматриваем сейчас                                                         
те, что можно настраивать более точно под каждое поле.                                                                           

принцип названия прост: `validate_<field_name>(self, value)`, где                                                          
`<field_name>` - название поля, которое собираетесь валидировать,                                                        
`value` в аргументах - значение, которое как раз будет браться у этого поля.                                                  
Дальше уже свои настройки пишите, как нужно. В этом случае мы будем внимательно                                                   
следить за тем, чтобы длина значений была строго в пределах от 3 до 30 символов                                                   
по длине, и от 4 до 25 символов по длине. Иначе будем выкидывать ошибку.                                                     

Процесс регистрации для моделей типа `ViewSet` отличается от обычного:                                     

сперва необходимо импортировать определённый класс - `DefaultRouter`,                                                         
который поможет нам зарегистрировать наши урлики.                                                                     

После, по этому классу нужно создать объект, обычно его называют `router`                                                     
После уже мы можем заниматься регистрацией новых урликов. Мы можем                                                              
вызвать метод `register()` у созданного нами объекта, после чего передать                                                   
нужные аргументы:                                                                      
1) название нового url - обычно это название модели                                                         
2) класс-отображение, который будет работать с этими `url`                                                           


В самом конце эти `urls` нужно будет добавить к обычным `urlpatterns`                                                                       

```python
from rest_framework.routers import DefaultRouter

from apps.categories.views import CategoryViewSet


router = DefaultRouter()

router.register(r'', CategoryViewSet)

urlpatterns = router.urls

```

У нас ещё остались подзадачи, которые мы не делали\
Сперва мы создадим сериализаторы, которые будут отображать наши подзадачи:

```python
from rest_framework import serializers

from apps.subtasks.models import SubTask


class SubTaskInfoSerializer(serializers.ModelSerializer):
    class Meta:
        model = SubTask
        fields = [
            'id',
            'title',
            'description',
            'status',
            'deadline'
        ]


class ListSubTaskSerializer(serializers.ModelSerializer):
    class Meta:
        model = SubTask
        fields = '__all__'
```

После чего можно приступить к написанию класса-отображения:

```python
from rest_framework.exceptions import ValidationError
from rest_framework.generics import ListCreateAPIView
from rest_framework.request import Request
from rest_framework.response import Response
from rest_framework import status

from apps.subtasks.serializers import ListSubTaskSerializer
from apps.subtasks.models import SubTask


class ListSubTasksGenericView(ListCreateAPIView):
    serializer_class = ListSubTaskSerializer

    def get_queryset(self):
        subtasks = SubTask.objects.all()

        return subtasks

    def get(self, request: Request, *args, **kwargs):
        subtasks = self.get_queryset()

        serializer = self.serializer_class(subtasks, many=True)

        return Response(
            status=status.HTTP_200_OK,
            data=serializer.data
        )

    def post(self, request: Request, *args, **kwargs):
        raw_data = request.data

        try:
            serializer = self.serializer_class(data=raw_data)

            serializer.is_valid(raise_exception=True)
            serializer.save()

            return Response(
                status=status.HTTP_201_CREATED,
                data=serializer.data
            )
        except ValidationError as err:
            return Response(
                status=status.HTTP_400_BAD_REQUEST,
                data=err.detail
            )

```

Новый метод для вас - `get_queryset()`. Он на самом деле достаточно прост.\
Если метод `get_object()` помогает нам выбрать какую-то конкретную сущность,\
то как раз этот метод `get_queryset()` позволяет нам взять СПИСОК каких-то сущностей.

И не забываем зарегистрировать это дело:

```python
from django.urls import path

from apps.subtasks.views import ListSubTasksGenericView


urlpatterns = [
    path('', ListSubTasksGenericView.as_view()),
]

```

В случае, если мы хотим получить возможность смотреть сразу данные и по                                                       
`foreign_key` полям (например фронт хочет, чтобы мы присылали ему информацию                                                     
о конкретной задаче и о всех подзадачах для неё) - мы так же можем настраивать                                               
это дело. Обычно настройки такого типа происходят в сериализаторах:                                                        


Сперва создадим новый сериализатор для подзадач:                                                             

```python
class SubTaskSerializer(serializers.ModelSerializer):
    class Meta:
        model = SubTask
        fields = ['id', 'title', 'category', 'status', 'date_started']
```

После чего создадим новый сериализатор, который будет выводить информацию                                                       
именно о конкретной задаче и списке всех её подзадачах:                                                          

```python
from rest_framework import serializers

from apps.tasks.models import Task
from apps.subtasks.serializers import SubTaskInfoSerializer


class TaskInfoSerializer(serializers.ModelSerializer):
    subtasks = SubTaskInfoSerializer(many=True, read_only=Task)
    category = serializers.SlugRelatedField(
        slug_field='name',
        read_only=True
    )

    class Meta:
        model = Task
        fields = [
            'id',
            'title',
            'description',
            'category',
            'status',
            'creator',
            'subtasks',
            'date_started',
            'deadline',
            'updated_at',
        ]


class TaskSerializer(serializers.ModelSerializer):
    class Meta:
        model = Task
        fields = [
            'id',
            'title',
            'description',
            'category',
            'status',
            'creator',
            'date_started',
            'deadline',
            'updated_at',
        ]

```

Для того, чтобы это было возможно - создаём переменную, которая называется                                                       
так же, как и наше `related_name` в модели, и в эту переменную закидываем                                                   
наш новый сериализатор для всех подзадач. В нём мы прописываем настройки,                                                   
что записей может быть много и что эти конкретные данны только для чтения.                                                

ПОсле чего эту переменную мы включаем в список отображаемых полей.                                                      

Главное - на забыть потом в классе для отображения конкретной задачи поставить                                               
новый сериализатор.
