<!-- TOC -->
* [**HTTP**](#http)
* [**CORS**](#cors-)
* [**Tokens**](#tokens)
  * [**Authentication Authorisation**](#authentication-authorisation-)
  * [**Sessions**](#sessions-)
* [**CSRF**](#csrf-)
* [**JWT**](#jwt-)
  * [**Аутентификация с использованием JWT**](#аутентификация-с-использованием-jwt-)
* [**Microservices and monoliths**](#microservices-and-monoliths)
  * [**monoliths**](#monoliths-)
  * [**Microservices**](#microservices-)
<!-- TOC -->

# **HTTP**                                                                             

Протокол прикладного уровня. На самом старте он в основном использовался                                                                                                                              
разработчиками для передачи всяких там HTML в интернет. ЧТобы красиво                                                                                                                                
всё отрисовывать на сайтиках этих ваших. Но со временем он отошёл                                                                                                                           
от концепции посредника только для этого формата данных (HTML) и                                                                                                                            
стал общепринятым ВЭБ протоколом. Работает на основе TCP\UDP, Данные передаёт                                                                                                                              
так же кусочками (пакетами), но если все эти кусочки объединятся                                                                                                                          
вместе - мы получим полноценный объект - пакет.                                                                                                                            

Этот пакет делится на 2 части: `HEAD`, `BODY`                                                                                                                                     

`HEAD` -  отвечает за хранение информации (где, как, что, куда)                                                                             
`BODY` - именно там наш HTML и передаётся(или же `JSON`, или что-то ещё)                                                                                                                         

Нас, как будущих вэб-разработчиков интересует именно `head`. Там могут                                                                                                                            
храниться наши эндпоинты, методы, статусы, мета информация(сколько объект                                                                                                                             
весит, куда его забросить, какой у него формат, токены доступа и т.д.)                                                                                                                            


URL - является нашим эндпоинтом, состоит из доменного имени, региона,                                                                                                                                  
самого эндпоинта, параметров                                                                              

METHODS - каким образом наш эндпоинт нужно обработать. Типы запросов.                                                                                                                                   
**GET**, **POST**, **PUT**, **PATCH**, **DELETE**                                                                                                                                  

Вместо того, чтобы каждый раз писать для каждого эндпоинта по пять                                                                                                                        
различных отвлетвлений (прочитать новости, удалить новость, обновить(частично))                                                                                                                     
новость, создать новость - мы можем написать один класс-отображение, благодаря                                                                                                                       
которому манипулировать этими методами, создавая определённую логику.                                                                                                                                
Будет всего один класс-отображение, в котором будут висеть различные методы.                                                                                                                         
Такой подход называется **REST**.                                                                                                                                                                       


**REST** (`Representational State Transfer`) - это архитектурный стиль для разработки                                                                                                                                                                      
веб-сервисов. Он определяет набор правил для создания веб-сервисов, включая                                                                                                                                                                      
методы **HTTP**, **URL** и **MIME**-типы.                                                                                                                                                                     

**Принципы REST**:                                                                                                                                                                     

Без сохранения состояния (**Stateless**): Каждый запрос от клиента к серверу                                                                                                                                                                     
должен содержать всю информацию, необходимую для выполнения запроса. Сервер                                                                                                                                                                      
не хранит информацию о предыдущих запросах.                                                                                                                                                                     

**Клиент-сервер (Client-Server)**: Клиент (например, веб-браузер) и сервер работают                                                                                                                                                                      
независимо друг от друга.                                                                                                                                                                     

Единообразие интерфейса (`Uniform Interface`): **REST** использует стандартные                                                                                                                                                                      
операции **HTTP** (**GET**, **POST**, **PUT**, **DELETE**), которые соответствуют операциям CRUD.                                                                                                                                                                     

Без состояния ресурсов (Stateless Resources): В REST ресурсы (такие как объекты                                                                                                                                                                     
в базе данных) идентифицируются URL-ами. Например, /students может                                                                                                                                                                      
представлять всех студентов, а `/students/123` - конкретного студента с `ID 123`.                                                                                                                                                                     

**Связь между CRUD и REST:**                                                                                                                                                                     

* `Create`: соответствует методу HTTP POST                                                                                                                                                                     
* `Read`: соответствует методу HTTP GET                                                                                                                                                                     
* `Update`: соответствует методу HTTP PUT или PATCH                                                                                                                                                                     
* `Delete`: соответствует методу HTTP DELETE Таким образом, CRUD и REST                                                                                                                                                                      
тесно связаны.                                                                                                                                                                     
**CRUD** определяет основные операции, которые мы можем выполнять над данными,                                                                                                                                                                     
а **REST** представляет способ организации веб-сервисов вокруг этих операций,                                                                                                                                                                     
используя стандартные методы и принципы веба.                                                                                                                                                                     


**STATUSES** - быстрый, ёмкий и доступный способ понять, как прошёл запрос.                                                                                                                                                                     

Статусов достаточно много и все они разнятся на следующие категории:                                                                                                                                

**100-199** - подсказки разного рода.                                                                                                                       
**200-299** - сообщения об успешном запросе.                                                                                                                       
**300-399** - перенаправляния                                                                                                                       
**400-499** - ошибки клиента                                                                                                                       
**500-599** - обишки сервера                                                                                                                       


---

# **CORS**                                                                                                                                                                 

**CORS** (`Cross-Origin Resource Sharing`) — это механизм **безопасности**, который                                                                                                                        
регулирует, как веб-приложения на одном источнике (домене) могут взаимодействовать                                                                                                                       
с ресурсами на другом источнике. **CORS Headers** играют ключевую роль в этом механизме.                                                                                                                       

**Зачем нужны CORS Headers?**                                                                                                                       
`Контроль безопасности`: **CORS** предотвращает потенциально вредоносные сайты                                                                                                                        
от чтения чувствительных данных с вашего сайта. Например, если вы залогинены в                                                                                                                        
банк, вредоносный сайт не сможет сделать запрос к банку и украсть вашу информацию.                                                                                                                       

`Гибкость для разработчиков`: **CORS Headers** позволяют разработчикам указать,                                                                                                                        
какие источники допустимы для доступа к ресурсам. Это полезно, если у вас                                                                                                                       
есть публичное **API**, которое вы хотите открыть для всех, или частное **API**,                                                                                                                       
доступное только для определенных доменов.                                                                                                                       

**Основные CORS Headers:**                                                                                                                       
* `Access-Control-Allow-Origin`: Указывает, какие домены могут получить доступ                                                                                                                        
к ресурсу. Без этого заголовка браузеры блокируют запросы между доменами.                                                                                                                       

* `Access-Control-Allow-Methods`: Определяет, какие HTTP-методы (GET, POST и                                                                                                                        
т. д.) разрешены для использования при запросе к ресурсу.                                                                                                                       

* `Access-Control-Allow-Headers`: Указывает, какие HTTP-заголовки можно                                                                                                                        
использовать в запросе.                                                                                                                       

* `Access-Control-Allow-Credentials`: Управляет тем, могут ли сайты передавать                                           
учетные данные, такие как куки, при запросе.                                                                                                                       

**Почему без них нельзя?**                                          

Без **CORS Headers** браузеры применяют политику одного источника (`same-origin`                                          
`policy`), которая блокирует запросы к другим доменам. Это означает, что                                          
веб-приложение на одном домене не может запрашивать данные с другого                                           
домена без явного разрешения через **CORS**.                                          

**Пример:**                                          
Предположим, у вас есть веб-приложение на `example.com`, которое хочет получить                                          
данные с вашего **API** на `api.example.com`. Без настройки **CORS**, браузер                                           
заблокирует этот запрос.                                          

Если вы на сервере `api.example.com` установите заголовок `Access-Control-Allow-Origin`                                           
со значением `https://example.com`, запросы с `example.com` будут разрешены, и                                           
ваше веб-приложение сможет получить данные.                                          

**Вывод:**                                          
**CORS Headers** обеспечивают баланс между безопасностью и гибкостью, позволяя                                           
разработчикам контролировать, как их ресурсы могут быть доступны другим                                          
доменам. Без этих заголовков взаимодействие между разными доменами было бы                                           
**невозможным** из-за ограничений безопасности браузера.                                                             

---

# **Tokens**                                                                             

Токен в контексте компьютерной безопасности и программирования — это небольшой                                                              
фрагмент данных, который служит символом или заместителем чего-то ещё. Он                                                             
может представлять собой разные вещи в зависимости от контекста, в                                                              
котором используется.                                                             


## **Authentication Authorisation**                                                             
В контексте аутентификации и авторизации токен — это секретный ключ, который                                                             
выдается пользователю после успешного входа в систему. Он может быть использован                                                              
для доказательства идентичности пользователя или для выполнения определенных                                                             
действий от имени пользователя.                                                             

**Примеры:**                                                             

**Токен доступа** (`Access Token`): Предоставляет доступ к определенным ресурсам                                                             
или службам. Например, `OAuth2` использует токены доступа для авторизации                                                              
третьих сторон, чтобы действовать от имени пользователя.                                                             

**Токен обновления** (`Refresh Token`): Может быть использован для получения                                                              
нового токена доступа без необходимости ввода имени пользователя и                                                              
пароля заново.                                                             


## **Sessions**                                                             

**Токен сессии** — это уникальный идентификатор, который генерируется и                                                              
отправляется пользователю при успешной аутентификации. Он затем используется                                                              
для идентификации пользователя во всех последующих запросах в рамках сессии.                                                             

**Устройства безопасности**                                                             

Физические токены, такие как смарт-карты или специализированные устройства                                                              
для двухфакторной аутентификации, также могут называться токенами. Они                                                             
хранят секретные ключи или цифровые сертификаты и могут использоваться для                                                             
аутентификации в различных системах.                                                             

**Вывод**                                                             
Токен, в общем смысле, является символическим или фактическим заместителем                                                             
некоторой информации или права. Он может быть цифровым ключом, символьным                                                             
идентификатором, физическим устройством или даже просто строкой, которая                                                             
олицетворяет или представляет что-то ещё в определенном контексте.                                                             

**Примеры из жизни**                                                             

Вот три примера из реальной жизни, которые могут служить аналогией для токена                                                             
в цифровом мире:                                                             

**Билет на поезд или самолет**: Билет служит "**токеном**", подтверждающим ваше                                                              
право на место в транспортном средстве. Как и цифровой токен, он связан                                                              
с вашей личностью (или, по крайней мере, с бронированием) и позволяет                                                             
вам получить доступ к определенной услуге, в данном случае — путешествию.                                                             

**Жетон для игровых автоматов**: Жетон в игровом автомате служит заместителем                                                              
реальных денег и даёт возможность играть в автомат. Он может быть                                                              
использован только в определенном контексте (в данном случае,                                                              
в автомате) и предоставляет доступ к определенной услуге или функции.                                                             

**Ключ от номера в гостинице**: Этот ключ (или карта-ключ в современных                                                              
гостиницах) является **физическим "токеном"**, который подтверждает ваше право                                                             
на доступ в определенный номер гостиницы. Так же как и цифровой токен                                                              
авторизации, он дает право доступа к защищенному ресурсу (в данном                                                              
случае, вашему номеру) и связан с вашей идентификацией как                                                              
гостя гостиницы.                                                             

Эти примеры иллюстрируют, как токен может служить заместителем или                                                              
символом чего-то ещё, будь то права доступа, идентификация или                                                             
даже денежные средства, в различных сценариях реального мира.

---
# **CSRF**                                                             

`CSRF (Cross-Site Request Forgery)` — это тип атаки, при которой                                                             
злоумышленник может заставить пользователя выполнить нежелательное                                                              
действие на веб-сайте, на котором он аутентифицирован. `CSRF-токен` —                                                              
это защитный механизм, который предотвращает такие атаки.                                                             

**Особенность и назначение CSRF-токена**                                                             
`CSRF-токен` уникален для каждого пользователя и сессии. Он гарантирует, что                                                             
запрос, отправленный на сервер, действительно исходит от аутентифицированного                                                              
и авторизованного пользователя, а не от злоумышленника, который пытается                                                              
воспользоваться сессией пользователя.                                                             

**Как он работает**                                                             
**Генерация токена**: Когда пользователь заходит на сайт и аутентифицируется,                                                              
сервер генерирует уникальный `CSRF-токен`. Этот токен затем вставляется в                                                              
формы на веб-странице в виде скрытого поля или добавляется в заголовки                                                             
`HTTP-запросов`.                                                             

**Хранение токена**: Токен также хранится на стороне сервера или в сессии                                                             
пользователя. Он должен оставаться секретным, чтобы злоумышленники не                                                              
могли его угадать или украсть.                                                             

**Проверка токена**: Когда пользователь отправляет запрос (например, при                                                              
отправке формы), `CSRF-токен` также отправляется на сервер. Сервер затем                                                             
сравнивает этот токен с токеном, хранящимся в сессии пользователя. Если                                                              
токены совпадают, запрос считается легитимным. Если нет — запрос отклоняется,                                                              
так как есть вероятность, что он исходит от злоумышленника.                                                             

`CSRF-токен` в **Django** и в других системах защиты не просто случайная строка,                                                              
которую можно было бы подделать. Он связан с конкретной сессией пользователя,                                                              
и сервер ожидает определённого значения для каждой сессии. Вот почему                                                             
просто вставить придуманный токен не сработает:                                                             

**Связь с Сессией**: `CSRF-токен` связан с конкретной сессией пользователя, и                                                              
сервер знает, какой токен ожидать от каждой сессии. Если злоумышленник                                                              
просто придумает токен и вставит его в куки и форму, сервер при проверке                                                              
увидит, что токен не совпадает с ожидаемым для данной сессии,                                                             
и запрос будет отклонён.                                                             

**Уникальность**: Даже если злоумышленник каким-то образом украдет токен другого                                                              
пользователя, этот токен будет связан только с сессией этого конкретного                                                              
пользователя. Использование его в другом контексте также                                                              
приведет к ошибке.                                                             

**Безопасность передачи**: Токен передается через HTTPS (если сайт                                                              
настроен соответствующим образом), что делает перехват токена                                                              
злоумышленником еще сложнее.                                                             

**Жизненный цикл**: Токены могут иметь временные ограничения, по                                                             
истечении которых они становятся недействительными.                                                             

Таким образом, механизм защиты от CSRF не просто ожидает любой токен                                                              
в куках и форме; он ожидает конкретного токена, связанного с конкретной                                                             
сессией, и проводит строгую проверку. Это делает атаки путем                                                              
подделки токена практически невозможными.                                                             

---
# **JWT**                                                             

`JWT (JSON Web Tokens)` - это компактный и самодостаточный способ передачи                                                              
информации между сторонами в формате JSON. Информация может быть подтверждена                                                              
и доверена, так как она подписана. JWT часто используется для аутентификации                                                             
и передачи информации о пользователях между клиентом и сервером.                                                             

`JWT` состоит из трёх частей:

* **Заголовок (Header)**: Определяет тип токена и используемый алгоритм                                                              
подписи, например HMAC `SHA256` или `RSA`.                                                             

* **Полезная нагрузка (`Payload`)**: Содержит утверждения (`claims`),                                                             
которые являются заявлениями о сущности (обычно пользователе) и                                                             
дополнительных данных. Некоторые из них зарезервированы и имеют                                                              
определенные названия, но вы также можете добавлять                                                              
свои утверждения.

* **Подпись (Signature)**: Чтобы создать подпись, нужно закодировать                                                              
заголовок и полезную нагрузку с помощью `Base64Url` и объединить их                                                              
точкой, затем подписать полученную строку секретным ключом.

## **Аутентификация с использованием JWT**                                                             

1) Пользователь вводит свои учетные данные (логин и пароль).                                                               
2) Сервер проверяет учетные данные и при успешной проверке создает                                                               
JWT, подписанный своим секретным ключом.                                                               
3) JWT отправляется пользователю.                                                               
4) Пользователь сохраняет токен и отправляет его с каждым следующим запросом.                                                               
5) Сервер проверяет подпись токена, чтобы гарантировать его                                                               
целостность и аутентичность.                                                               


**Вопросы и моменты, на которые стоит обратить внимание:**                                                               

**Безопасность**: Нельзя хранить важные конфиденциальные данные в JWT, так как                                                               
содержимое может быть прочитано. Шифрование может использоваться                                                                
для скрытия содержимого.                                                               

**Срок годности**: JWT может иметь срок годности, что является хорошей                                                               
практикой для снижения рисков безопасности.                                                               

**Место хранения токена**: Токены могут быть уязвимыми к краже, поэтому                                                                
их хранение и передача требуют осмотрительности.                                                               

**Отзыв токенов**: JWT не имеет встроенного механизма отзыва, поэтому,                                                               
если токен скомпрометирован, его нельзя просто "отозвать". Возможные решения                                                                
могут включать использование коротких сроков жизни токена                                                               
и обновление токенов.                                                               

**Размер**: JWT может быть относительно большим по сравнению с другими                                                                
токенами, поэтому нужно об этом помнить, особенно если используете                                                                
их в URL или заголовках.                                                               

`JWT` предоставляет мощный инструмент для работы с аутентификацией и                                                                
авторизацией, но его нужно использовать осторожно и осознанно,                                                                
особенно в отношении безопасности.                                                               

`JWT` (`JSON Web Token`) является стандартизированным способом представления                                                                
заявлений между двумя сторонами. Главная особенность JWT заключается в                                                                
том, что он может быть самодостаточным, то есть содержать всю необходимую                                                               
информацию в себе, и эта информация может быть верифицирована                                                                
и надёжно зашифрована.                                                               

При получении токена сервер может декодировать его и проверить подпись, используя                                                                
тот же секретный ключ, что и при создании токена. Если подпись не совпадает,                                                                
это означает, что токен был изменён, и он будет отклонён.                                                               

Таким образом, можно сказать, что JWT похож на контрольную сумму в том смысле,                                                               
что он предоставляет способ проверки целостности данных. Но в отличие от простой                                                                
контрольной суммы, JWT также может содержать информацию, верифицировать                                                                
отправителя, и быть защищённым от подделки благодаря                                                                
использованию криптографической подписи.

Давайте рассмотрим шаги работы клиента и сервера с JWT токеном, начиная с                                                                
аутентификации пользователя и заканчивая использованием токена                                                                
для защиты конечных точек (endpoints).                                                               

**Аутентификация Пользователя**:                                                               

1) **Клиент отправляет** учетные **данные** пользователя (например, имя                                                                
пользователя и пароль) на сервер.                                                               

2) **Сервер проверяет** учетные **данные**, и если они действительны, генерирует JWT токен.                                  

3) **В заголовке** токена указывается **алгоритм подписи** (например, `HS256`).                                                               

4) В **полезной нагрузке** могут быть указаны различные утверждения, такие как                                                                
**идентификатор пользователя**, **роли** и другие атрибуты.                                                               

5) **Сервер подписывает** токен с использованием **секретного ключа**.                                                               

6) **Токен отправляется обратно** клиенту, который сохраняет его, обычно в                                                                
заголовке **Authorization** или в куках.                                                               
---

**Использование Токена**:                                                               

1) **Клиент делает запрос** к защищенному ресурсу на сервере, включая `JWT`                                                               
токен в заголовке **Authorization**.                                                               

2) **Сервер извлекает токен** и **проверяет его подпись** с использованием того                                                               
же секретного ключа, который использовался для создания подписи.                                                               

3) **Если подпись недействительна** (например, токен был изменен или                                                               
подделан), **сервер отклоняет запрос**.                                                               

4) **Если подпись действительна**, сервер затем может **проверить дополнительные**                                                               
утверждения в токене, такие как **срок годности**.                                                               

5) **Сервер извлекает информацию** о пользователе из полезной нагрузки токена                                                                
(например, идентификатор пользователя) и использует ее для                                                                
выполнения операции, если все проверки прошли успешно.                                                               

6) **Ответ возвращается клиенту.**                                                               


**Обновление Токена (при необходимости):**                                                               

Если токен имеет **ограниченный срок действия**, клиент может понадобиться                                                               
**обновить его**.                                                               
Это **может быть** выполнено с помощью **отдельного обновляемого токена** или                                                               
другого механизма, зависящего от конкретной реализации.                                                               


**Логаут (при необходимости):**                                                               

Клиент может **удалить** сохраненный `JWT` токен, чтобы выполнить операцию                                                                
**выхода из системы**.                                                               
В некоторых системах сервер также может сохранять "**черный список**"                                                                
отозванных токенов, чтобы предотвратить их дальнейшее использование.                                                               
Этот процесс охватывает большую часть жизненного цикла `JWT` в типичном                                                                
взаимодействии клиент-сервер. На каждом этапе могут существовать                                                                
дополнительные проверки и шаги в зависимости от конкретных                                                                
требований системы.                                                               


**Примеры из жизни**
Вот три аналогии из реальной жизни, которые могут напомнить работу                                                               
с JWT токеном:                                                               

1) **Паспорт или Водительское Удостоверение**: Ваш паспорт или водительское                                                                
удостоверение содержит **личную информацию** и фотографию, а также                                                                
подписаны уполномоченным органом (например, правительством). Когда                                                                
вы предъявляете его в аэропорту или при остановке полицией, они                                                                
могут проверить его подлинность и определить вашу личность. Это похоже                                                               
на то, как сервер проверяет подпись `JWT токена` и извлекает                                                                
информацию о пользователе из полезной нагрузки.                                                               

2) **Билет на Концерт или Мероприятие**: Когда вы покупаете билет на концерт,                                                               
он может содержать **уникальный штрих-код** или `QR-код`, который отражает                                                               
информацию о месте, дате и времени мероприятия. Входной контроль сканирует                                                                
ваш билет и проверяет информацию в базе данных, чтобы убедиться, что                                                               
билет действителен. Это схоже с тем, как `JWT токен` содержит утверждения                                                                
о пользователе и сервер проверяет их при каждом запросе.                                                               

3) **Запечатанный Конверт с Подписью**: Если вы получаете запечатанное письмо с                                                                
подписью отправителя на печати, вы можете быть уверены в том, что письмо не                                                               
было вскрыто или изменено после того, как его запечатали. Сервер,                                                               
который проверяет подпись `JWT токена`, работает аналогичным образом,                                                                
проверяя, что токен не был изменен с момента его создания.
---

# **Microservices and monoliths**

Микросервисы и монолиты — это два подхода к архитектуре программного                                                 
обеспечения, и они имеют свои сильные и слабые стороны.                                       

## **monoliths**                                                                                      

**Описание:**                                       

**Единое Приложение**: В монолитной архитектуре всё приложение строится                                       
как один крупный блок кода.                                       
**Общая База Данных**: Обычно используется одна база данных для всего                                        
приложения.                                       


**Преимущества:**                                       

**Простота Разработки**: Все части приложения в одном месте, поэтому                                        
разработка и тестирование часто проще.                                       
**Эффективное Использование Ресурсов**: Все части приложения работают                                        
в одном процессе, что может повысить эффективность.                                       

**Недостатки:**

**Масштабирование**: Если вам нужно масштабировать определенный компонент,                                        
вы должны масштабировать весь монолит.                                       
**Жёсткость**: Изменения в одной части могут затрагивать всю систему, что                                        
может затруднить обновления и поддержание кода.                                                           


## **Microservices**                                                                                                            

**Описание**:                                                           

Разделение на Сервисы: Приложение разбито на множество небольших,                                                            
автономных сервисов. Каждый микросервис выполняет конкретную                                                            
задачу или функцию.                                                           

Независимость: Микросервисы могут разрабатываться, тестироваться,                                                           
развертываться и масштабироваться независимо друг от друга.                                                           


**Преимущества**:

Гибкость и Масштабирование: Можно легко масштабировать или изменить                                                            
отдельные части системы.                                                           

Технологическая Агностика: Разные микросервисы могут использовать разные                                                            
технологии, языки программирования и базы данных.                                                           


**Недостатки**:

Сложность Управления: Управление множеством независимых сервисов                                                            
может быть сложным.                                                           
Задержки Сети: Поскольку микросервисы общаются между собой через сеть,                                                           
это может добавить дополнительную задержку.                                                           


**Пример**:
**Монолит**: Онлайн-магазин как одно большое приложение, включая каталог                                                            
продуктов, корзину, платежи и т. д.                                                           

**Микросервисы**: Тот же онлайн-магазин, но разбитый на отдельные сервисы:                                                            
один для каталога, один для корзины, один для платежей и так далее.                                                           

**Заключение**:
Монолиты лучше подходят для небольших или простых проектов, где преимущества                                                           
одной кодовой базы перевешивают недостатки.                                                           

Микросервисы предпочтительнее для крупных и сложных систем, где гибкость                                                            
и масштабируемость являются ключевыми факторами.                                                           

Выбор между этими двумя подходами будет зависеть от специфики проекта,                                                            
требований к нему, а также от опыта и предпочтений команды разработчиков.                                                           
---

**Правила создания микросервесного приложения**                                                         


Создание микросервисного приложения может быть сложным процессом, и                                                          
существует несколько важных принципов и правил, которыми                                                          
стоит руководствоваться:                                                         

1) **Определите Границы Сервисов**: Каждый микросервис должен иметь чётко                                                         
определенную ответственность и функциональность. **Один сервис - одна задача**.                                                         

2) **Независимость**: Микросервисы должны быть **независимы друг от друга**. Они                                                          
могут разрабатываться, развертываться и масштабироваться отдельно.                                                         

3) **Децентрализованное Управление Данными**: **Каждый микросервис** должен иметь                                                         
**собственную базу данных**, чтобы избежать связанности и                                                         
зависимости между сервисами.                                                         

4) **Автоматизация**: Применяйте автоматизацию для развертывания, мониторинга                                                          
и масштабирования сервисов. Это снизит сложность управления ими.                                                         

5) **Стандартизация Общения**: Все микросервисы должны общаться через **хорошо**                                                          
**определенные** и **стандартизированные интерфейсы**, такие как `REST` или `gRPC`.                                                         

6) **Обработка Сбоев**: Разработайте стратегии для обработки сбоев и                                                         
отказоустойчивости, так как сбои в одном сервисе не                                                         
должны влиять на другие.                                                         

7) **Мониторинг и Логирование**: Имейте систему мониторинга и логирования                                                          
для отслеживания состояния каждого микросервиса.                                                         

8) **Безопасность**: Обеспечьте надежную безопасность на уровне каждого                                                         
микросервиса, включая аутентификацию и авторизацию.                                                         

9) **Контейнеризация**: Используйте технологии контейнеризации, такие как                                                          
Docker, чтобы упростить развертывание и управление микросервисами.                                                         

10) **Сохраняйте Культуру CI/CD**: Постоянная интеграция и непрерывная доставка                                                         
(CI/CD) должны быть ключевыми компонентами вашего рабочего процесса.                                                         

11) **Документация**: Обеспечьте подробную и актуальную документацию для каждого                                                         
микросервиса, чтобы упростить сотрудничество и поддержку.                                                         

12) **Проектирование для Изменений**: Разрабатывайте микросервисы так, чтобы они                                                         
могли легко адаптироваться к изменениям требований или технологий.                                                         

13) **Рассмотрите Общие Библиотеки**: Для устранения дублирования кода рассмотрите                                                         
возможность создания общих библиотек, которые могут быть                                                         
использованы разными микросервисами.                                                         

14) **Оценивайте Сложность**: Микросервисы могут быть переусложнены для небольших                                                         
проектов. Оцените, подходит ли этот подход для вашего конкретного случая.                                                         

Соблюдение этих принципов может способствовать успешному проектированию и                                                          
внедрению микросервисного приложения, минимизируя распространенные                                                          
проблемы и сложности этого подхода.                                                         
