<!-- TOC -->
* [**Django**](#django)
* [**Frameworks, libraries**](#frameworks-libraries)
* [**Advantages of frameworks**](#advantages-of-frameworks)
* [**The role of libraries in development**](#the-role-of-libraries-in-development)
* [**Popular Frameworks**](#popular-frameworks)
* [**Django**](#django-1)
* [**Why use Django**](#why-use-django)
* [**Get started**](#get-started)
* [**Django's structure**](#djangos-structure-)
* [**How to create applications?**](#how-to-create-applications)
* [**First project's settings**](#first-projects-settings)
* [**Microservices and monoliths**](#microservices-and-monoliths)
  * [**monoliths**](#monoliths-)
  * [**Microservices**](#microservices-)
<!-- TOC -->
# **Django**

# **Frameworks, libraries**

**Фреймворк и библиотека** - два важных понятия в мире программирования.     


**Фреймворк** представляет собой набор инструментов, шаблонов и структур,       
предназначенных для упрощения и ускорения процесса разработки        
приложений. 

**Библиотека**, с другой стороны, предоставляет набор функций       
и классов для выполнения конкретных задач, но не накладывает жестких        
ограничений на архитектуру проекта.


# **Advantages of frameworks**

1. **Ускорение разработки:** Фреймворки предоставляют готовые компоненты и      
структуры, которые сокращают время разработки и упрощают процесс      
создания приложения.


2. **Соблюдение стандартов:** У каждого фреймворка есть свои стандарты по         
написанию кода, структуре проекта и т.д.


3. **Безопасность:** Многие фреймворки включают в себя механизмы безопасности,        
такие как защита от CSRF-атак и инструменты для обработки ввода пользователей.


4. **Масштабируемость:** Фреймворки обычно предоставляют структуры, которые        
легко масштабировать для обработки роста пользовательской нагрузки.


# **The role of libraries in development**

1. **Переиспользование кода:** Библиотеки предоставляют готовые функции и классы,          
которые можно легко использовать в различных проектах, что способствует       
переиспользованию кода.


2. **Разделение ответственности:** Использование библиотек позволяет       
разделить приложение на модули, каждый из которых отвечает за определенную        
функциональность.


3. **Улучшение обслуживаемости:** Поддержка и обновление библиотек       
может быть более простой задачей, чем разработка всей функциональности с нуля.



# **Popular Frameworks**

1. [Django](https://www.djangoproject.com/) - это высокоуровневый фреймворк, известный своей полноценной        
функциональностью для разработки веб-приложений. Он включает `ORM`      
(`Object-Relational Mapping`), административный интерфейс и множество        
инструментов для ускорения разработки.


2. [Flask](https://flask.palletsprojects.com/en/2.3.x/) - это легковесный фреймворк, предоставляющий базовые        
инструменты для создания веб-приложений. Он предоставляет большую свободу в        
выборе компонентов и архитектуры проекта.


3. [Pyramid](https://trypyramid.com/) - гибкий фреймворк, ориентированный на разработку       
больших и сложных веб-приложений. Он поддерживает различные подходы      
к разработке и архитектуре.


4. [FastAPI](https://fastapi.tiangolo.com/)- современный фреймворк, оптимизированный для        
создания `API`. Он предоставляет автоматическую генерацию        
документации и обладает высокой производительностью.


---

# **Django**

**Django** - это бесплатный и открытый фреймворк для разработки вебприложений        
на Python, который предоставляет программистам инструменты и структуру      
для создания эффективных и масштабируемых веб-приложений.

# **Why use Django**

* **Django** широко применяется в индустрии и имеет доказанную репутацию        
в области разработки веб-приложений. **Instagram**, **Pinterest**, **NASA**, **The**      
**Washington Post** и др. построены с использованием `Django`.     


* Имеет в наличии разнообразные расширения и пакеты, которые      
предоставляют доп.функции и инструменты для разработки. Например,    
расширения для работы с `API`, аутентификации, аналитики, CMS и др.      


* Поддерживает использование различных БД (`PostgreSQL`,     
`MySQL`, `SQLite`, `Oracle` и др), что даёт разработчикам гибкость выбора     
наиболее подходящей БД.    


* Имеет большое и активное сообщество разработчиков, которое      
предоставляет богатую документацию, библиотеки и модули     
расширения для упрощения разработки веб-приложений.

---

# **Get started**

Для начала необходимо создать\перейти папку, где вы хотите видеть                                                     
свой проект, собственно.                                                   

Проект на Django можно создавать несколькими вариациями:                                                 

1) Непосредственно через интерфейс `Pycharm Professional`:                                                         
    * открыть меню                                                   
    * нажать new project                                                  
    * В правой вкладке выбрать Django                                                  
    * В лефой стороне настроить будущий проект (                                                  
    дать ему имя, настроить виртуальное окружение, настроить                                                   
    будушую шаблонизацию, если нужно)                                                  
    * Нажать на кнопку создания, что находится внизу.                                                  

2) Через терминал:                                                  

    * Создать необходимый каталог, где будет проект.                                                  
    * перейти в него, открыть там терминал                                                  
    * создать внутри каталога виртуальное окружение: (`python -m venv venv`)                                                   
    * активировать виртуальное окружение: (`source venv/bin/activate`)                                                   
    * внутри него прописать команду: `pip install django`                                                   
    * после этого успешного успеха в терминале необходимо ввести следующее                                                   
    `django-admin startproject <name_of_your_project>`                                                   
    * Эта команда создаст нам стартовую структуру нашего с вами проекта.                                                   


---

# **Django's structure**                                                   

Давайте разберёмся более детально, что у нас тут вообще происходит:                                                   

После создания проекта у нас с вами должна создаться следующая                                                    
структура:                                                   

`<project_name>/` - папка, в которой будет валяться наш проект, +                                                    
виртуальное окружение, + папка, отвечающая за будущие шаблоны, +                                                    
файл-менеджер.

`templates/` - эта папка будет отвечать за хранение всех наших `html`                                                   
шаблонов, которые мы будем (или не будем) создавать. Генерируется                                                   
автоматически.                                                   

`manage.py` - спец файлик-менеджер. Он отвечает за запуск нашего приложения.                                                   
в его функции `main()` идёт чтение и инициализация всех наших настроек проекта                                                   
которые мы будем создавать, а так же посредничество проекта с консолью                                                   
терминала. Именно через этого менеджера мы будем общаться с нашим проектом                                                   
что-то создавать, что-то обновлять, применять.                                                   

`<project_name>/` - сам наш проект, в котором будет много чего лежать:                                                                  

* `__init__.py` - файл, благодаря которому папка, в которой был обозначен                                                                  
этот файл, будет восприниматься не как папка, а как класс, все файлы - как                                                                  
атрибуты класса.                                                                  

* `asgi.py` - более новый стандарт, предназначенный для асинхронной обработки                                                                   
запросов. Это означает, что сервер может одновременно обрабатывать несколько                                                                   
запросов, что делает его более подходящим для приложений с высокой                                                                   
производительностью и веб-сокетов.                                                                                            

* `wsgi.py` - используется для настройки стандартного способа взаимодействия                                                                    
между веб-серверами и приложениями на **Python**. `WSGI` является более традиционным                                                                    
и широко используемым в `Django`. Он предназначен для синхронной обработки запросов,                                                                    
что означает, что в один момент времени обрабатывается один запрос.                                                     

* `urls.py` - играет важную роль в определении схемы `URL` веб-приложения.                                                                                             
Он служит для "routing" различных `URL`-адресов на соответствующие                                                                                             
представления (`views`), которые обрабатывают входящие запросы                                                                                            
и возвращают ответы.                                                                                             
Является центральной частью любого `Django`-проекта, поскольку он направляет                                                                                              
входящий трафик на соответствующие части приложения.                                                                                              
Внутри могут располагаться такие массивы, как `urlpatterns`, в которых                                                    
находятся функции `path()`. Именно благодаря этим функциям мы можем                                                     
создавать новые частички ответвлений нашего приложения, эндпоинты.                                                    
Эта функция `path()` принимает зачастую **два** аргумента - часть                                                    
пути, сам эндпоинт собственно. ОН передаётся в виде строчки.                                                    
И что-то, что должно отработать при тригерре этого пути. Это может быть                                                    
или какая-то функция, или даже специальная функция `include()`, которая                                                    
позволит нам включить в этот путь различные другие эндпоинты из другого                                                    
приложения.                                                                          


* `settings.py` - это место, где хранятся все конфигурации вашего проекта.                                                                          
Он содержит настройки, связанные с базой данных, безопасностью, шаблонами,                                                                           
статическими файлами и многим другим.                                                                                                         

    * `DEBUG`: Определяет, должен ли `Django` выводить подробные отчеты об ошибках.                                                                                
    Установите в `True` во время разработки, но обязательно смените на `False`                                                                                
    в продакшн-среде.                                                                               

    * `SECRET_KEY`: Используется для криптографической подписи, важен для безопасности                                                                               
    вашего приложения. Должен быть уникальным и храниться в безопасности.                                                                               

    * `ALLOWED_HOSTS`: Список хостов/доменов, для которых может работать                                                                               
    данный `Django`-сайт.                                                                               

    * `INSTALLED_APPS`: Список всех Django-приложений, которые активны в вашем проекте.                                                
    Сюда мы будем записывать все созданные нами приложения, и так же доп функционал для                                     
    фреймворка, который мы будем устанавливать через пакетный менеджер `pip`                                                     

    * `MIDDLEWARE`: Список `middleware`, которые используются в вашем приложении.                                                  
    **Middleware** - это слои, которые выполняются при каждом запросе/ответе и могут                                                   
    выполнять различные функции, например, обработку сессий, `CSRF`-защиту.                                                  

    * `ROOT_URLCONF`: хранит в себе путь к самому главному url файлу, от которого                                                
    и будет начинаться маршрутиризация                                                                    

    * `TEMPLATES`: Настройки, связанные с системой шаблонов Django, включая                                                     
    пути к директориям с шаблонами.

    * `WSGI_APPLICATION`: хранит в себе путь к файлу настроек работы синхронного                                                
    сервера

    * `DATABASES`: определяются конфигурации базы данных. `Django` поддерживает                                                          
    несколько СУБД, включая `PostgreSQL`, `MySQL`, `SQLite`.                                                              

    * `AUTH_PASSWORD_VALIDATORS`: содержит в себе уже готовые настройки                                                     
    на валидацию пароля(да, вам, условно, не нужно будет писать их                                                          
    самим. уже есть под капотом.)                                                       

    * `LANGUAGE_CODE`: Настройки, относящиеся к языку вашего приложения                                                       

    * `TIME_ZONE`: Настройки, относящиеся к временной зоне                                                       

    * `USE_I18N`: относится к международизации (i18n) приложения.                                                             
    Если `USE_I18N` установлен в `True`, **Django** будет использовать систему **международизации**.                                                       
    Это означает, что ваше приложение может поддерживать **множество языков** и культур,                                                        
    делая его доступным для более широкой аудитории. Вы также можете работать с                                                        
    другими связанными настройками, такими как `LANGUAGE_CODE` (**стандартный язык                                                        
    вашего сайта**) и `LANGUAGES` (**список языков, которые поддерживает ваш сайт**).                                                       
    Вам также может потребоваться использовать `USE_L10N` для настройки локализации,                                                       
    чтобы включить **специфичное для локали форматирование данных**.                                                       

    Если `USE_I18N` установлен в `False`, поддержка международизации **отключается**.                                                        
    Это может быть полезно, если вы разрабатываете приложение, предназначенное                                                        
    для использования в одном языковом и культурном контексте.

    * `USE_TZ`: отвечает за использование тайм зоны.

    * `STATIC_URL`:  Определяет, как **Django** обрабатывает статические                                                   
    файлы (`CSS`, `JavaScript`, **изображения**).                                                  

    * `DEFAULT_AUTO_FIELD`: поле, которое подвязано к созданию первичных ключей в моделях.                                                

---

# **How to create applications?**

По хорошему для каждой новой сущности в вашем проекте должно быть отдельное                                             
приложение. Весь ваш проект будет строиться именно на них. Допустим,                                                      
вы хотите реализовать работу с новостями - создаёте приложение `news`, и в                                                 
этом приложении будет только тот код, который должен относиться именно к                                                
новостям.

Для того, чтобы создавать приложения, существует специальная команда в терминале                                        
и в целом, как я говорил вам, "общаться" с нашим проектом мы будем через терминал                                       
посредством специального менеджера.                                                    

# **First project's settings**

Для того, чтобы правильно начать работать, нужно немного навести порядок во всём том                                     
что мы будем там создавать. По умолчанию, когда мы создаём проект на Django,                                             
нам выдаётся уникальный `SECRET_KEY` для этого проекта. Это уникальный                                                  
ключ, токен, благодаря которому мы, собственно, и можем работать с нашим проектом.                                       
Думаю объяснять вам не нужно, что этот ключ ни коем образом не должен попасть в гит.                                    

Поэтому нам необходимо будет с вами настроить немного наш дефолтный проект, убрав                                           
из него всякие секретные штуки, чтобы они не попали в гит.                                                   

1) Создадим вайл `.env` и отправим в него необходимые нам данные.                                                     
2) В файле `<your_project.settings.py>` необходимо найти этот `SECRET_KEY`,                                               
забрать его значение и переместить в `.env` файл.                                          
3) Настроить работу с переменными окружения на нашем проекте в этом файле                                                 
настроек.                                                                   
4) так же мы можем убрать ещё и переменную `DEBUG`, пусть так же валяется в `.env`                                       

Сам проект мы можем переименовать в `config`, так как по факту у нас там будут                                             
только разные настройки для нашего проекта и всё.                                                                  

приложения наши мы будем создавать в отдельном модуле, который создадим,                                                 
который назовём `apps`.                                                                

После того, как мы с вами создали приложение, его необходимо "зарегистрировать"                                           
в файле настроек `settings.py`, чтобы наш проект знал наше новое приложение и мог                                      
с ним работать. ДЛя этого в переменной `INSTALLED_APPS` добавим наше приложение:                                          

```python

...
    "django.contrib.messages",
    "django.contrib.staticfiles",

    # local
    "apps.news.apps",
```


Для того, чтобы создать новое приложение, нам необходимо ввести от такую команду:                                         
`python manage.py startapp <app_name>`                                                       

Эта команда создаст нам новое приложение в рамках нашего проекта. у этого приложения                                    
есть так же своя инфраструктура:                                                  

`migrations/`: специальная папка-модуль, в которой будут храниться все миграции                                         
конкретно для этого приложения. Каждый новый файл миграции будет попадать именно                                        
сюда. У каждого приложения своя папка миграций.                                      

`__init__.py`: файл, благодаря которому папка, в которой был обозначен                                                                  
этот файл, будет восприниматься не как папка, а как класс, все файлы - как                                                                  
атрибуты класса.                                                                  

`admin.py`: отвечает за регистрацию созданных моделей в панели администратора.                                          
есть несколько вариаций, как же эти модели там регистрировать. От самого                                                
простого, но не практичного, до достаточно интересного, благодаря                                                       
которому можно точечно настраивать эту модель, отображения и фильтрации, всё.                                            

`apps.py`: отвечают за регистрацию всего приложения. Оставляем обычно так, как они есть.                                      

`models.py`: собственно отвечают за создание и настройку моделей, их доп поведения.                                         

`tests.py`: в таких файлах описываем все тесты для приложения.                                                        

`views.py`: один из основных наших файлов. Именно в нём мы и будем создавать наши                                           
функции, или классы-отображения, которые будут отрабатывать на какие-то эндпоинты                                            
и что-то делать.

---

Давайте немного попишем чего!                                                          

для начала, чтобы мы могли уже что-то делать(хотя это не супер обязательно)                                            
давайте сделаем вот что: `Django` на самом старте, просто при                                                  
инициализации, "дарит" нам достаточно много функционала. Включая свои дефолтные                                            
модели, которые нам с вами необходимо применить, создав первичную структуру базы                                        
данных.                                                     

Делаться это всё будет на протяжении всей нашей работы, на основе таких команд, как                                      
"сбор миграций" и "применение миграций"                                                  

1) `python manage.py makemigrations` - команда, которая будет пробегаться                                                
по всем нашим приложениям, по каждой папке `models` и смотреть шо где изменилось.                                           
На основе всех найденных изменений это устройство хитрое чекнет, валидны ли изменения,                                     
не накосячили ли мы с вами как-то, всё ли сходится и нет ли каких-то конфликтов                                            
между другими моделями и их полями. Если всё гуд - будут созданы специальные                                            
файлы миграций, в которых достаточно подробно будет описано шо да как должно                                             
быть применено.                                                                
2) `python manage.py migrate` - применяет все новые миграции на основе созданных                                             
файлов миграций, обновляя тем самым вашу базу данных.                                                                   

Дальше мы можем создать себе пользователя для работы в админ панели.                                             
Да, Django на самом старте вам даёт уже ГОТОВУЮ админ панель!!!!!                                                 
Просто бери и пользуйся (настроить главное не забудь).                                                        

Эта панель позволяет нам работать с нашими моделями, создавать новые записи                                            
обновлять, удалять данные, фильтровать, группировать и т.д.                                                             
Для того, чтобы туды можно было зайти, необходимо создать суперпользователя:                                          

В терминале набираем `python manage.py createsuperuser`. Эта команда                                               
постепенно, шаг за шагом будет у вас запрашивать нужные данные, которые будут                                            
в последствии записаны в модель пользователя, которую Django даёт ПО УМОЛЧАНИЮ.                                          

---

Далее можно, на самом деле, для более удобной работы в дальнейшем,                                                  
разделить всю нашу маршрутеризацию:                                             

В модуле `apps` можно создать файл `router.py`, который будет заниматься                                          
перенаправлением наших будущих эндпоинтов с разных приложений.                                               
Это позволит нам более комфортно работать в эндпоинты, разделяя их                                              
бизнес логику: эндпоинты для новостей лежат только в файле `urls.py`                                                   
из приложения `news`.                                                     

в этом файле `router.py` нам необходимо прописать следующее:                                                
```python
from django.urls import path, include

urlpatterns = [
    path("news/", include("apps.news.urls"))    
]

```

И в приложении `news` нам необходимо будет создать файл `urls.py`.                                            

```python
from django.urls import path

from apps.news.views import (
    hello_world,
    home_page,
)

urlpatterns = [
    path("", hello_world),
    path("about/", home_page),
]
```

Вторым аргументом здесь мы с вами передали как раз функции-отображения,                                           
которые нам необходимо будет создать и реализовать уже в файле `views.py`                                            

```python
from django.shortcuts import render


def hello_world(request):
    return render(
        request=request,
        template_name='news/hello_world.html'
    )
```

Все наши функции-отображения, которые мы будем с вами создавать, должны                                              
первым аргументом в себе содержать аргумент `request` - спец объект нашего                                               
запроса. В этом объекте запроса может храниться достаточно много полезной                                         
информации. Это по факту и есть наш с вами "пакет" данных, который мы                                                 
принимаем от фронта\клиента.                                                      

Далее, в первой функции, мы сразу же возвращаем выполнение функции `render()`                                          

Эта функция как раз и занимается отображением какого-то результата(каких-то                                              
данных) на сайте (HTML странице).                                                  

Из основных там два аргумента: `request`, и `template_name`.                                                     

`request` - передаём, собственно, объект запроса, по какому запросу мы возвращаем                                        
какой-то ответ.

`template_name` - это как раз и есть - сам наш `HTML` шаблон. Мы прописываем                                           
в этом аргументе строку с путём, по которому наш шаблон и хранится.                                             


Сам `HTML` шаблон может выглядеть от так от:                                                

```html
<!doctype html>  <!-- тип страницы -->
<html lang="en">  <!-- язык страницы -->
<head> <!-- хэд данные страницы -->
    <meta charset="UTF-8">  <!-- тип кодировки страницы -->
    <meta name="viewport"  
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">  <!-- метаданные -->
    <title>Document</title>  <!-- то, как страница будет обзываться во вкладке -->
</head>  <!-- закрывающий тег -->
<body>  <!-- тело страницы. Весь HTML скилет, который мы будем создавать, будет именно в теле. -->
    <div>  <!-- специальный блок. Обычно в них всё и строится. Чем-то похож аналогией на наши классы -->
        <h1 style="color: brown">HELLO FROM THE 'HTML' TEMPLATE!!!</h1>  <!-- заголовок первого уровня. Есть настройка стиля. Тект в этом параграфе будет тёмно-красного цвета. -->
    </div>  <!-- закрывающий тег -->
</body>  <!-- закрывающий тег -->
</html>  <!-- закрывающий тег -->
```

Что же делать, как именно нужно писать код, когда мы хотим не просто какую-то                                            
тестовую дичь отобразить, а когда мы хотим отображать, передавать какие-то данные                                       
прямиком из базы данных?                                                     

Для этого в наших функциях-отображениях мы можем определить дополнительный                                              
аргумент - `context`.                                                         

```python
def about_page(request):
    context = {
        "user": request.user,
    }

    return render(
        request=request,
        template_name='news/about_page.html',
        context=context
    )
```

Мы можем создать словарик, в котором будут необходимые нам ключи и значения.                                            
КОнкретно в этом примере мы будем формировать словарик с данными о пользователе,                                        
который запрос сделал. Сделать мы это можем, обратившись к аргументу запроса,                                          
который к нам пришёл, и через точку достав из него объект пользователя(кто сделал запрос).                                 

После чего этот словарик мы и передаём в третий, не обязательный аргумент функции                                           
`render()` - `context`


Как это будет выглядить уже в самом шаблоне?                                                     

```html
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
    <body>
        <div>
            <div>
                <h2>{{ user.username }}</h2><!-- специальный синтаксис шаблонизатора Django. В этих двойных
                фигурных скобках мы и прописываем те ключи, которые были в нашем контексте -->
                <h3>{{ user.email }}</h3>  <!-- В нашем случае у нас был один ключ - user, который
                 является объектом пользователя, который и сделал запрос.-->
                <h4>{{ user.date_joined }}</h4>  <!-- И у этого пользователя мы и вытягиваем через точку
                 нужные нам данные. Которые будут отрисованы в каждом таком элементе HTML, который мы указали-->
            </div>
        </div>
</body>
</html>
```

# **Microservices and monoliths**

Микросервисы и монолиты — это два подхода к архитектуре программного                                                 
обеспечения, и они имеют свои сильные и слабые стороны.                                       

## **monoliths**                                                                                      

**Описание:**                                       

**Единое Приложение**: В монолитной архитектуре всё приложение строится                                       
как один крупный блок кода.                                       
**Общая База Данных**: Обычно используется одна база данных для всего                                        
приложения.                                       


**Преимущества:**                                       

**Простота Разработки**: Все части приложения в одном месте, поэтому                                        
разработка и тестирование часто проще.                                       
**Эффективное Использование Ресурсов**: Все части приложения работают                                        
в одном процессе, что может повысить эффективность.                                       

**Недостатки:**

**Масштабирование**: Если вам нужно масштабировать определенный компонент,                                        
вы должны масштабировать весь монолит.                                       
**Жёсткость**: Изменения в одной части могут затрагивать всю систему, что                                        
может затруднить обновления и поддержание кода.                                                           


## **Microservices**                                                                                                            

**Описание**:                                                           

Разделение на Сервисы: Приложение разбито на множество небольших,                                                            
автономных сервисов. Каждый микросервис выполняет конкретную                                                            
задачу или функцию.                                                           

Независимость: Микросервисы могут разрабатываться, тестироваться,                                                           
развертываться и масштабироваться независимо друг от друга.                                                           


**Преимущества**:

Гибкость и Масштабирование: Можно легко масштабировать или изменить                                                            
отдельные части системы.                                                           

Технологическая Агностика: Разные микросервисы могут использовать разные                                                            
технологии, языки программирования и базы данных.                                                           


**Недостатки**:

Сложность Управления: Управление множеством независимых сервисов                                                            
может быть сложным.                                                           
Задержки Сети: Поскольку микросервисы общаются между собой через сеть,                                                           
это может добавить дополнительную задержку.                                                           


**Пример**:
**Монолит**: Онлайн-магазин как одно большое приложение, включая каталог                                                            
продуктов, корзину, платежи и т. д.                                                           

**Микросервисы**: Тот же онлайн-магазин, но разбитый на отдельные сервисы:                                                            
один для каталога, один для корзины, один для платежей и так далее.                                                           

**Заключение**:
Монолиты лучше подходят для небольших или простых проектов, где преимущества                                                           
одной кодовой базы перевешивают недостатки.                                                           

Микросервисы предпочтительнее для крупных и сложных систем, где гибкость                                                            
и масштабируемость являются ключевыми факторами.                                                           

Выбор между этими двумя подходами будет зависеть от специфики проекта,                                                            
требований к нему, а также от опыта и предпочтений команды разработчиков.                                                           
---

**Правила создания микросервесного приложения**                                                         


Создание микросервисного приложения может быть сложным процессом, и                                                          
существует несколько важных принципов и правил, которыми                                                          
стоит руководствоваться:                                                         

1) **Определите Границы Сервисов**: Каждый микросервис должен иметь чётко                                                         
определенную ответственность и функциональность. **Один сервис - одна задача**.                                                         

2) **Независимость**: Микросервисы должны быть **независимы друг от друга**. Они                                                          
могут разрабатываться, развертываться и масштабироваться отдельно.                                                         

3) **Децентрализованное Управление Данными**: **Каждый микросервис** должен иметь                                                         
**собственную базу данных**, чтобы избежать связанности и                                                         
зависимости между сервисами.                                                         

4) **Автоматизация**: Применяйте автоматизацию для развертывания, мониторинга                                                          
и масштабирования сервисов. Это снизит сложность управления ими.                                                         

5) **Стандартизация Общения**: Все микросервисы должны общаться через **хорошо**                                                          
**определенные** и **стандартизированные интерфейсы**, такие как `REST` или `gRPC`.                                                         

6) **Обработка Сбоев**: Разработайте стратегии для обработки сбоев и                                                         
отказоустойчивости, так как сбои в одном сервисе не                                                         
должны влиять на другие.                                                         

7) **Мониторинг и Логирование**: Имейте систему мониторинга и логирования                                                          
для отслеживания состояния каждого микросервиса.                                                         

8) **Безопасность**: Обеспечьте надежную безопасность на уровне каждого                                                         
микросервиса, включая аутентификацию и авторизацию.                                                         

9) **Контейнеризация**: Используйте технологии контейнеризации, такие как                                                          
Docker, чтобы упростить развертывание и управление микросервисами.                                                         

10) **Сохраняйте Культуру CI/CD**: Постоянная интеграция и непрерывная доставка                                                         
(CI/CD) должны быть ключевыми компонентами вашего рабочего процесса.                                                         

11) **Документация**: Обеспечьте подробную и актуальную документацию для каждого                                                         
микросервиса, чтобы упростить сотрудничество и поддержку.                                                         

12) **Проектирование для Изменений**: Разрабатывайте микросервисы так, чтобы они                                                         
могли легко адаптироваться к изменениям требований или технологий.                                                         

13) **Рассмотрите Общие Библиотеки**: Для устранения дублирования кода рассмотрите                                                         
возможность создания общих библиотек, которые могут быть                                                         
использованы разными микросервисами.                                                         

14) **Оценивайте Сложность**: Микросервисы могут быть переусложнены для небольших                                                         
проектов. Оцените, подходит ли этот подход для вашего конкретного случая.                                                         

Соблюдение этих принципов может способствовать успешному проектированию и                                                          
внедрению микросервисного приложения, минимизируя распространенные                                                          
проблемы и сложности этого подхода.                                                
