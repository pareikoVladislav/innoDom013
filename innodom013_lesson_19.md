<!-- TOC -->
* [**Databases. Intro**](#databases-intro-)
* [**A little piece of history**](#a-little-piece-of-history-)
* [**Types of databases**](#types-of-databases-)
* [**Database management system**](#database-management-system-)
* [**Installation**](#installation-)
* [**Core elements of the Database**](#core-elements-of-the-database-)
* [**Типы таблиц и ключей в реляционных БД.**](#типы-таблиц-и-ключей-в-реляционных-бд-)
* [**SQL**](#sql-)
* [**SQL QUERIES STRUCTURE**](#sql-queries-structure-)
* [**CREATE TABLE**](#create-table-)
* [**INSERT**](#insert-)
* [**SELECT, FROM**](#select-from-)
* [**WHERE**](#where-)
* [**GROUP BY**](#group-by-)
* [**HAVING**](#having)
* [**UPDATE**](#update)
* [**DELETE**](#delete-)
* [Примечание: убедитесь, что используете **WHERE**, когда удаляете запись из таблицы.](#примечание-убедитесь-что-используете-where-когда-удаляете-запись-из-таблицы-)
* [Иначе вы удалите все записи из таблицы, сами того не желая.](#иначе-вы-удалите-все-записи-из-таблицы-сами-того-не-желая-)
* [**TRUNCATE**](#truncate-)
* [**DROP**](#drop-)
* [**SQL Инъекции**](#sql-инъекции-)
<!-- TOC -->

# **Databases. Intro**                                                              

**Базы данных (БД)** - это **организованная структура**, предназначенная       
для **хранения информации**. Обычно БД представляются в виде **совокупности**       
**взаимосвязанных файлов или таблиц**, предназначенных для решения         
конкретной задачи.                                                              


# **A little piece of history**                                                             

Базы данных были разработаны в ответ на растущие потребности в упорядоченном                                                               
хранении и управлении большими объемами информации. В самом начале эры                                                              
компьютерных технологий, когда впервые возникла потребность в систематизации                                                              
данных, программисты обычно сохраняли информацию прямо в файлах.                                                              

**Однако это вызывало ряд проблем**:                                                              

* **Дублирование данных**: Разные программы могли хранить одни и те же данные,                                                               
что приводило к их ненужному дублированию.                                                              
* **Низкая эффективность**: Поиск и обработка данных в файлах были медленными,                                                               
особенно с увеличением объемов информации.                                                              
* **Сложность обновления**: Внесение изменений в данные, хранящиеся в файлах,                                                               
было сложным и подверженным ошибкам процессом.                                                              
* **Проблемы доступности и безопасности**: Управление доступом к файлам и их                                                               
защита от несанкционированного доступа было затруднительно.                                                              

Перед лицом этих проблем, разработчики стали искать более эффективные способы                                                              
управления данными. Это привело к созданию первых баз данных, которые                                                               
обеспечивали централизованное хранение информации, удобные механизмы для                                                              
поиска, фильтрации и обновления данных, а также повышенную безопасность                                                              
и контроль за доступом к информации.                                                              

С тех пор концепция баз данных постоянно развивалась, приводя к созданию                                                              
различных типов систем управления базами данных (**СУБД**), каждая из которых                                                               
предлагает свои уникальные возможности и оптимизирована для решения                                                              
конкретных задач.                                                              

---

# **Types of databases**                                                              

В целом базы данных делят на две категории: **реляционные** и **нереляционные**                                                                                                        


1) **Реляционные базы данных (РБД)**                                                              

**Реляционные** базы данных основаны на **реляционной** модели, которая использует                                                              
**таблицы** для хранения данных. Каждая таблица состоит из **строк** и **столбцов**, где                                                               
**строки представляют записи**, а **столбцы** - **атрибуты записей**.                                                              

В каждой таблице есть **уникальный ключ** (обычно это **столбец** или **набор столбцов**),                                                               
который идентифицирует каждую запись в таблице.                                                              


**Плюсы:**                                                              

* **Структурированность**: Легкость в организации и понимании структуры данных.                                                              
* **Мощные запросы**: **SQL** (язык структурированных запросов) позволяет выполнять                                                               
сложные запросы для извлечения и анализа данных.                                                              
* **Целостность данных**: Строгие правила и ограничения обеспечивают высокую                                                               
целостность и надежность данных.                                                              


**Минусы:**                                                              

* **Масштабируемость**: Может быть проблематичной в случае очень больших объемов                                                               
данных и высоких требований к производительности.                                                              
* **Жесткая структура**: Модификация схемы данных может быть сложной и трудоемкой.                                                              


2) **Нереляционные базы данных (NoSQL)**                                                              

Нереляционные базы данных представляют собой более гибкий подход к хранению данных.                                                               
Они могут хранить **неструктурированные** или **полуструктурированные** данные и **не требуют**                                                              
**жесткой схемы таблиц**. Существуют различные типы **NoSQL** баз данных, включая                                                               
**документо-ориентированные**, **ключ-значение**, **графовые** и **колоночные** базы данных.                                                              


В зависимости от типа **NoSQL** базы данных, могут использоваться различные механизмы                                                               
**идентификации записей**, например, **уникальные идентификаторы** в                                                               
**документо-ориентированных** базах.                                                              


**Плюсы:**                                                              

* **Гибкость**: Легкость адаптации к изменениям в структуре данных.                                                              
* **Масштабируемость**: Хорошо подходят для работы с большими объемами данных                                                              
и обеспечивают высокую производительность.                                                              
* **Разнообразие структур данных**: Поддержка различных форматов данных,                                                               
включая **JSON**, **XML** и другие.                                                              


**Минусы:**                                                              

**Ограниченные запросы**: Языки запросов могут быть менее мощными                                                               
по сравнению с **SQL**.                                                              
**Сложность**: Может быть сложно выбрать подходящий тип **NoSQL** базы данных для                                                              
конкретного приложения.                                                              
**Целостность данных**: Менее строгие ограничения могут привести к проблемам                                                              
с целостностью данных.                                                              


Оба типа баз данных имеют свои преимущества и недостатки, и выбор между                                                              
ними часто зависит от конкретных требований проекта, таких как **объем данных**,                                                               
**скорость обработки**, **структура данных** и **требуемая гибкость**.                                                              


Весь смысл использования **базы данных** в том, что когда данных становится                                                                        
больше, чем несколько книг в этом вашем экселе и эти данные внезапно становится                                                                        
невероятно **сложно структурировать**, а попытки получить полный список приводят                                                                          
среднестатистический компьютер в состояние синего экрана от нагрузки, то в дело                                                                          
вступают **СУБД**, которые берут на себя это нелегкое и весьма оплачиваемое                                                                           
со стороны крупных предприятий бремя.                                                              

---

# **Database management system**                                                              

ДЛя удобной работы с этими безумно полезными и сложными(некоторым) сущностями                                                                                                                            
разработчики придумали специальные системы управления, которые, в зависимости                                                                                                                             
от определённой системы могут отличаться друг от друга по синтаксису,                                                                                                                             
типам данных, структурах запросов и прочим параметрам.                                                                                                                            

**СУБД** освобождает разработчика от задач **хранения, модификации и поиска данных**.                                                                                                                                            
Его дело — **указать**, какие данные взять, и что с ними **сделать**.                                                                                                                                        
Все остальное сделает сама **СУБД**.                                                                                                                            

1) **Oracle**                                                                                                                            

[Oracle](https://www.oracle.com/)                                                              
Огромная сложная махина, для работы с которой требуются админы 80 уровня с сертификатами,                                                                                                                                   
подготовка коих стоит с десяток килобаксов. Умеет делать все, вплоть до того, что может                                                                                                                                       
выступать движком для веб приложений ([APEX](https://apex.oracle.com/en/) называется).                                                               
Работает на **Unix**, **винде** и еще черт знает чем.                                                                                                                             
Стоит эпических деньжищ, так что, ее могут себе позволить только                                                                                                                                        
большие конторы, что у нас, что на Западе. **P.S.** если ты не собираешься на ней                                                                                                                                        
крутить производственную базу, а просто разрабатываешь приложения, изучаешь или играешься,                                                                                                                                       
то скачать и пользоваться ей можно абсолютно бесплатно, даже самой ентерпрайзной                                                                                                                                       
версией, что есть таки вин.                                                                                                                            


2) **MS SQL Server**                                                                                                                            

[MS SQL Server](https://www.microsoft.com/en-us/sql-server)                                                              
**Microsoft** в свое время, в лучших своих традициях, подсуитилась и стырила **СУБД у Sybase**.                                                                                                                                     
С тех пор, как они заявляют, ее полностью переписали. **СУБД** получилась уровнем                                                                                                                                      
пониже **Oracle**, хотя, по этому поводу идут свои споры. Для управления **БД** используется                                                                                                                                       
почти исключительно **UI**, что несколько роднит эту систему с **Delphi**: вместо знания **DDL** тут                                                                                                                                         
нужно знать куда тыкнуть мышкой. Ну, есть еще **PowerShell**, но он никому не нужен. Раньше                                                                                                                                          
работал исключительно под Виндой, но начиная с 2016-й версии подружился с **Linux**.                                                                                                                            


3) **PostgreSQL**                                                                                                                            

[PostgreSQL](https://www.postgresql.org/)                                                              
Этот ваш **open source** во всей своей силе. Была разработана в университете Беркли, откуда еще                                                                                                                                    
много чего повыходило. Древняя — **Ingres**, от которого произошел **PostgreSQL**                                                                                                                                      
(собственно, **Post Ingres**) начинал разрабатываться еще **в начале** **70-ых**, когда этого вашего                                                                                                                                   
**Oracle** в проекте не было. Справедливости ради, следует заметить, что с изначальным                                                                                                                                   
Ingres'ом современный **Postgres** общего имеет почти что ничего, т.к. **в конце 80-ых** был                                                                                                                                     
практически полностью переделан. Довольно таки успешна, как для продукта столь древнего,                                                                                                                                   
достаточно быстро развивается, имеется большое количество сторонних приблуд.                                                                                                                                    
Ее уважают админы **Oracle** за то, что авторы не выеживались, а нормально следовали                                                                                                                                   
стандартам. Как и в случае многих других open source программ, очень хреново уживается с                                                                                                                                    
виндой.                                                                                                                            


4) **MySQL**                                                                                                                            

[MySQL](https://www.mysql.com/)                                                              
Тоже **open source**, но более дикий и лохматый. Самая популярная база для создания веб-сайтов,                                                                                                                                    
входит в состав так называемого **LAMP (**Linux**,** Apache**, **MySQL**, **PHP**)**. Поддерживает несколько                                                                                                                                   
движков **СУБД**, из которых не все поддерживают транзакции **ACID** (движок **MyISAM** как раз такой).                                                                                                                                   
**До 5-ой версии был объектом всеобщих насмешек из-за слабого функционала**, неполноценной                                                                                                                                    
поддержки даже древних стандартов **SQL** и обилия крайне сомнительных и костыльных решений, во                                                                                                                                   
многом спровоцированных как раз таки возможностью использования нескольких движков.                                                                                                                                 
Нынче все стало сильно получше, но, как следствие, изрядно усложнилась настройка — по                                                                                                                                  
сложности тюнинга современные версии приближаются к **PostgreSQL**. Впрочем, ситуаций, когда                                                                                                                                    
такой тюнинг реально нужен — одна на миллион. Однако, по закону вселенской несправедливости,                                                                                                                                   
такая ситуация обязательно возникнет именно **у тебя**.                                                                                                                            


5) **IBM DB2**                                                                                                                            

[IBM DB2](https://www.ibm.com/products/db2)                                                              
В свое время была весьма популярной и даже использовалась в качестве штатной **СУБД в Oracle**,                                                                                                                                     
однако в какой-то момент **IBM** откровенно забила на свое детище, в результате чего многие                                                                                                                                    
новомодные фишечки в нее попали сильно позже, чем у конкурентов. До сих пор где-то                                                                                                                                     
кем-то используется, но в сравнении с любой другой **СУБД** из данной статьи ее процент                                                                                                                                      
на рынке очень невелик.                                                                                                                            


6) **SQLite**                                                                                                                            

[SQLite](https://www.sqlite.org/index.html)                                                              
Это не столько **СУБД**, сколько библиотека, которая позволяет хранить данные в файле,                                                                                                                                     
обращаясь в нему как к базе данных с помощью **SQL**. Там тоже можно создавать таблицы                                                                                                                                     
и индексы, выполнять **DML** и запросы. Удобно в случае, если не хочется возиться с                                                                                                                                   
**XML** или создавать свой формат файла. Ныне имеется практически в каждом телефоне,                                                                                                                                    
хотя далеко не всякий разработчик знает, что это именно **SQLite** прячется за                                                                                                                                    
привычными вызовами **Android-API**                                                                                                                            


---

# **Installation**                                                                                  

На курсе мы, в основном, (как и на работе зачастую) будем работать                                                                                                                                                 
именно с **реляционными** базами данных. Одни из популярных на данный момент                                                                                                                                                
времени - **PostgreSQL** и **MySQL**.                                                                                                                                                

И там, и там необходимо создавать пользователя, через которого ваши базы                                                                                                                                                
данных и будут создаваться.                                                                                                                                                

**MySQL**                                                                                     

* **Windows:** - [msql installer](https://dev.mysql.com/downloads/installer/)                                                                                     
* **Linux:** - [MySQL](https://phoenixnap.com/kb/install-mysql-ubuntu-20-04)                                                                                     


* **PostgreSQL**                                                                                     

* **Windows:** - [PGAdmin](https://www.postgresql.org/download/windows/)                                                                                     
* **Linux:** - [PostgreSQL](https://ubuntu.com/server/docs/databases-postgresql)                                                                                     

---

# **Core elements of the Database**                                                                                     

Основным элементом **БД** является **таблица**. Столбцы таблицы **БД** называются **полями**,                                                                                                    
а строки — **записями**.                                                                                                                                                                           

Первым этапом создания таблицы **БД** является **задание ее структуры**, т.е.                                                                                      
**определение количества и типа полей**. Вторым этапом является ввод и                                                                                      
редактирование записей в таблицу.                                                                                               

**БД считается созданной, даже если она пустая.**                                                                                     


**Поля таблицы** просто **определяют ее структуру** и групповые свойства данных,                                                                                                 
записываемых в ячейках. Рассмотрим основные свойства полей БД.                                                                                     


* **Имя поля** — определяет как надо обращаться к данным поля (имена                                                                                      
используются как заголовки таблиц).                                                                                     
* **Тип поля** — определяет тип данных, которые могут содержаться в данном                                                                                      
поле (текстовые, числовые, дата, Memo, денежный, счетчик и др.).                                                                                     
* **Размер поля** — определяет предельную длину данных, которые могут                                                                                      
размещаться в поле.                                                                                     
* **Формат поля** — способ форматирования данных в ячейках.                                                                                     

---

# **Типы таблиц и ключей в реляционных БД.**                                                                                     

**Реляционные**(табличные) базы данных характеризуются наличием некоторых                                                                                               
типов таблиц и ключей, позволяющих определить отношения между таблицами.                                                                                              

Для того чтобы понять принципы разработки реляционных баз данных,                                                                                                
требуется дать определения различных типов реляционных ключей и таблиц:                                                                                     


* **Базовая таблица**. В реляционной базе данных **базовой таблицей** называется             
таблица, которая включает **один или несколько столбцов-свойств объекта**                                                                                                
**и содержит первичный ключ**, который однозначно определяет этот объект.                                                                                                
Более того, базовая таблица **должна** содержать **первичный ключ**. Базовые таблицы                                                                                                 
часто называют первичными, поскольку они имеют первичный ключ.                                                                                     


* **Промежуточная таблица**. Таблица, **не являющаяся базовой**                                                                                               
(т. к. она не объединяет свойства объекта или не содержит поле первичного ключа),                                                                                                
которая **используется для обеспечения связей между другими таблицами**, называется                                                                                               
**таблицей отношений**. Ключевые поля в таблицах отношений должны быть **внешними**                                                                                                 
**ключами**, связанными с **первичными ключами** базовой таблицы. Проще говоря,                                                                                               
таблица отношений состоит только из **внешних ключей и не содержит независимых**                                                                                            
**элементов** данных.                                                                                     


* **Первичный ключ**. Состоит из **набора значений, которые однозначно определяют**                                                                                             
**запись базовой таблицы**. Любому значению первичного ключа должна соответствовать                                                                                             
**одна и только одна строка таблицы**. **Первичный ключ** включает одно поле только                                                                                             
в том случае, если это поле не содержит повторяющихся значений.                                                                                     


* **Составные ключи**. Если для выполнения условий, накладываемых на значения                                                                                               
первичного ключа, заданный ключ включает несколько полей таблицы, то                                                                                                 
тогда он называется **составным**.                                                                                     


* **Внешние ключи** — это столбец, значения которого **соответствуют**                                                                                              
**значениям первичного ключа** другой связанной таблицы.                                                                                     

---

# **SQL**                                                                        

Устав от написания бесконечных процедур **поиска**, **вставки**, **удаления**, **замены**, программисты                                                                                
сообразили переложить эту обязанность на саму **СУБД**. Для этого они запилили **язык**                                                                                 
**структурированных запросов (SQL)**. Итог очевиден — вместо тысячи строк кода пишется                                                                                
одна строка, которая сделает ровно то, о чем ее просили, а не то, что породил больной                                                                                 
разум программиста. Плюсом — все изменения в базе данных выполняются одинаково,                                                                                 
что позволяет при правильном администрировании легко и быстро восстановить исходное                                                                                
состояние при сбоях и ошибках.                                                                        

**Data types in SQL:**                                                                      

| Строковые типы данных   | Описание                                                                                                                                                                                                                                                                               |
|-------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **CHAR**(size)          | Строки фиксированной длинны (могут содержать буквыб<br/>цифры и специальные символы. Фиксированный размер<br/>указан в скобках. Можно записать до 255 символов.)                                                                                                                       |
| **VARCHAR**(size)       | Может хранить не более 255 символов.                                                                                                                                                                                                                                                   |
| **TINYTEXT**            | Может хранить не более 255 символов.                                                                                                                                                                                                                                                   |
| **TEXT**                | Может хранить не более 65 535 символов.                                                                                                                                                                                                                                                |
| **BLOB**                | Может хранить не более 65 535 символов.                                                                                                                                                                                                                                                |
| **MEDIUMTEXT**          | Может хранить не более 16 777 215 символов.                                                                                                                                                                                                                                            |
| **MEDIUMBLOB**          | Может хранить не более 16 777 215 символов.                                                                                                                                                                                                                                            |
| **LONGTEXT**            | Может хранить не более 4 294 967 295 символов.                                                                                                                                                                                                                                         |
| **LONGBLOB**            | Может хранить не более 4 294 967 295 символов.                                                                                                                                                                                                                                         |
| **ENUM**(x, y, z, etc.) | Позволяет вводить список допустимых значений. Можно ввести<br/> до 65 535 значений в SQL ENUM - список. Если при вставке значения<br/>не будет присутствовать в списке ENUM, то мы получим пустое значение<br/> Ввести возможные значения можно в таком формате: ENUM ("X", "Y" , "X") |
| **SET**                 | Напоминает ENUM за исключением того, что SET может содержать до 64 значений.                                                                                                                                                                                                           |


| Числовые типы данных  | Описание                                                     |
|-----------------------|--------------------------------------------------------------|
| **TINYINT**(size)     | Может хранить числа от -128 до 127.                          |
| **SMALLINT**(size)    | Диапазон от -32 768 до 32 767.                               |
| **MEDIUMINT**(size)   | Диапазон от -8 388 608 до 8 388 607.                         |
| **INT**(size)         | Диапазон от -2 147 483 648 до 2 147 483 647.                 |
| **BIGINT**(size)      | Диапазон от -9 223 372 036 854 775 808 до 9 223 372 036 853. |
| **FLOAT**(size, d)    | Число с плавоющей точкой небольшой точности.                 |
| **DOUBLE**(size, d)   | Число с плавающей точкой двойной точности.                   |
| **DECIMAL**(size, d)  | Дробное число, хранящееся в виде строки.                     |


| Типы данных - дата и время  | Описание                                                                                                                                                   |
|-----------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **DATE**()                  | Дата в формате YYYY-MM-DD.                                                                                                                                 |
| **DATETIME**()              | Дата и время в формате YYYY-MM-DD HH:MM:SS.                                                                                                                |
| **TIMESTAMP**()             | Дата и время в формате timestamp. Однако при получении значения поля<br/>оно отображается не в формате timestamp, а в виде<br/>YYYY-MM-DD HH:MM:SS.        |
| **TIME**()                  | Время в формате HH:MM:SS.                                                                                                                                  |
| **YEAR**()                  | Год в двухзначном, или в четырёхзначном формате.                                                                                                           |

---

# **SQL QUERIES STRUCTURE**                                                                      

* **SELECT** ('столбцы или * для выбора всех столбцов; обязательно')                                                                      
* **FROM** ('таблица; обязательно')                                                                      
* **WHERE** ('условие/фильтрация, например, city = 'Minsk'; необязательно')                                                                      
* **GROUP BY** ('столбец, по которому хотим сгруппировать данные; необязательно')                                                                      
* **HAVING** ('условие/фильтрация на уровне сгруппированных данных; необязательно')                                                                      
* **ORDER BY** ('столбец, по которому хотим отсортировать вывод; необязательно')                                                                      


# **CREATE TABLE**                                                                      

Для того, чтобы создать таблицу в **SQL**, используется выражение **CREATE TABLE**.                                                                            
Он принимает в качестве параметров все колонки, которые мы хотим внести,                                                                              
а также их типы данных.                                                                      

Давайте создадим табличку с названием `"User"`, в которой будут следующие колонки:                                                                      

* **id** - иными словами, порядковый номер записи (целочисленный тип или int)                                                                      
* **name** - название пользователя (строка или varchar(10) (10 символов -                                                                       
максимальная длина строки))                                                                      
* **surname** - число дней в конкретном месяце (целочисленный тип или int)                                                                      
* **age** - возраст пользователя
* **country** - место, где он родился                                                                      
* **city** - город
* **phone** - его телефон                                                                      
* **email** - его имейл                                                                      

Код будет выглядеть вот так:                                                                      

```sql
CREATE TABLE user (
    id int PRIMARY_KEY NOT NULL,
    name varchar(10),
    surname varchar(25),
    age integer(100),
    country varchar(75),
    city varchar(50),
    phone varchar(35),
    email varchar(75)
    );
```

Также, когда создаются таблицы, принято добавлять так называемый **primary key**.                                                                             
Это колонка, значения в которой уникальны. Чаще всего **PK** колонкой                                                                              
является **id**, но в нашем случае это может быть и **email**, так как email                                                                      
всех пользователей уникальны.                                                                       

Более подробно можно ознакомиться [здесь](https://www.w3schools.com/sql/sql_primarykey.asp).                                                                      


# **INSERT**                                                                      

**Ввод данных**. Теперь давайте добавим пару пользователей в нашу табличку.                                                                       
Сделать это можно с помощью команды **INSERT**.                                                                             

Есть два разных способа использовать **INSERT**:                                                                      

1. Первый способ не подразумевает указания названий колонок, а лишь принимает                                                                             
значения в том порядке, в котором они указаны в таблице:                                                                      

```sql
INSERT INTO user VALUES (1, 'John', 'Doe', 30, 'USA', 'Mexico', '+987654321', 'j.doe97@gmail.com');
```

Первый способ короче второго, однако если в будущем мы захотим                                                                              
добавить дополнительные колонки, все предыдущие запросы работать                                                                             
не будут. Для решения данной проблемы следует использовать                                                                               
второй способ.                                                                      

2. Суть в том, что перед вводом данных мы указываем названия колонок.                                                                           
В случае, если мы не укажем одну из колонок, на её место будет записано                                                                             
**NULL** или заданное значение по умолчанию, но это уже совсем другая история.                                                                      

```sql
INSERT INTO user (id,name,surname,age,country,city,phone,email) VALUES (2,'Nick', 'Polsky', 23, 'Canada', 'Victoria', '+123456789', 'kuklovod50@gmail.com');
```

# **SELECT, FROM**                                                                           

**SELECT, FROM** — обязательные элементы запроса, которые определяют                                                                                   
выбранные столбцы, их порядок и источник данных.                                                                           

```sql
SELECT * FROM user
```

Результатом данного запроса будет таблица со всеми данными в                                                                                  
таблице **user**. Знак звёздочки (`*`) означает то, что мы хотим                                                                                  
показать **все столбцы из таблицы без исключений**. Так как в базе данных                                                                                   
обычно больше одной таблицы, нам необходимо указывать название                                                                                    
таблицы, данные из которой мы хотим посмотреть. Сделать это мы можем,                                                                                  
используя ключевое слово **FROM**.                                                                           


Когда вам нужны лишь некоторые столбцы из таблицы, то вы можете                                                                                 
указать их имена через запятую вместо звёздочки.                                                                           

```sql
SELECT id, name FROM user
```

# **WHERE**                                                                           

**WHERE** — необязательный элемент запроса, который используется, когда нужно                                                                                 
**отфильтровать данные по нужному условию**. Очень часто внутри элемента **where**                                                                                 
используются **IN / NOT IN** для фильтрации столбца по нескольким значениям, **AND / OR**                                                                                  
для фильтрации таблицы по нескольким столбцам.                                                                           


* **IN** - сравнивает значение в столбце с несколькими возможными                                                                            
значениями и возвращает **true**, если значение совпадает хотя                                                                            
бы с одним значением                                                                           
* **BETWEEN** - проверяет, находится ли значение в каком-то промежутке                                                                           
* **LIKE** - ищет по шаблону                                                                           

**Фильтрация по одному условию и одному значению:**                                                                           

```sql
SELECT * FROM user
WHERE city = 'London'
```

**Фильтрация по одному условию и нескольким значениям с применением**                                                                                  
`IN (включение) или NOT IN (исключение)`:

```sql
SELECT * FROM user
WHERE city IN ('London', 'Berlin')
```

```sql
SELECT * FROM user
WHERE city NOT IN ('Madrid', 'Berlin','Bern') 
```


Фильтрация по нескольким условиям с применением **AND** (выполняются все условия)                                                                                 
или **OR** (выполняется хотя бы одно условие) и нескольким значениям:                                                                           

```sql
select * from user
where country = 'Germany' AND age BETWEEN 18 AND 35
```

```sql
select * from user
where country in ('London', 'Berlin') OR age BETWEEN 18 AND 25
```

```sql
SELECT * FROM user
WHERE name LIKE "%on"
```

# **GROUP BY**                                                                      

**GROUP BY** — необязательный элемент запроса, с помощью которого можно                                                                               
задать агрегацию по нужному столбцу (например, если нужно узнать какое                                                                            
количество клиентов живет в каждом из городов).                                                                      

При использовании `GROUP BY` **обязательно**:                                                                      

1. перечень столбцов, по которым делается разрез, был одинаковым внутри                                                                           
`SELECT` и внутри `GROUP BY`                                                                       


2. агрегатные функции (`SUM`, `AVG`, `COUNT`, `MAX`, `MIN`)                                                                             
должны быть также указаны внутри `SELECT` с указанием столбца,                                                                             
к которому такая функция применяется.                                                                      


В `SQL` полно встроенных функций для выполнения разных операций. Мы                                                                       
же посмотрим только наиболее часто используемые:                                                                      


* **COUNT()** - возвращает число строк                                                                      
* **SUM()** - возвращает сумму всех полей с числовыми значениями в них                                                                      
* **AVG()** - возвращает среднее значение среди строк                                                                      
* **MIN()/MAX()** - возвращает минимальное/максимальное значение среди строк                                                                      


**Группировка количества пользователей по городу**:                                                                      

```sql
select city, count(id) from user
GROUP BY city
```

**Группировка количества пользователей по стране и городу**:                                                                      

```sql
select country, city, count(id) from user
GROUP BY country, city
```

Переименование столбца с агрегацией с помощью оператора AS. По                                                                       
умолчанию название столбца с агрегацией равно примененной агрегатной                                                                      
функции, что далее может быть не очень удобно для восприятия.                                                                      

```sql
select city, count(id) AS number_of_users from user
group by city
```

# **HAVING**

**HAVING** — необязательный элемент запроса, который отвечает за                                                                       
фильтрацию на уровне сгруппированных данных (по сути, **WHERE**, но                                                                       
только на уровень выше).                                                                      


Фильтрация агрегированной таблицы с количеством пользователей по городам, в данном                                                                              
случае оставляем в выгрузке только те города, в которых не менее 5 пользователей:                                                                      

```sql
select city, count(id) from user
group by city
HAVING count(id) >= 5
```

В случае с переименованным столбцом внутри **HAVING** можно указать                                                                       
как и саму агрегирующую конструкцию **count(id)**, так и новое название                                                                       
столбца **number_of_users**:                                                                      

```sql
select city, count(id) AS number_of_users from user
group by city
HAVING count(id) >= 5
```

Пример запроса, содержащего **WHERE** и **HAVING**. В данном запросе                                                                      
сначала фильтруется исходная таблица по пользователям, рассчитывается                                                                       
количество пользователей по городам и остаются только те города, где                                                                      
количество пользователей не менее 5:                                                                      

```sql
select city, count(id) as number_of_users from user
WHERE name not in ('Alex','Vlad')
group by city
HAVING number_of_users >= 5
```

# **UPDATE**

Зачастую нам нужно изменить данные в таблице. В **SQL** это делается                                                                       
с помощью **UPDATE**.                                                                      


Использование `UPDATE` включает в себя:                                                                      

* выбор таблицы в которой находится поле, которое мы хотим изменить                                                                      
* запись нового значения                                                                      
* использование **WHERE**, чтобы обозначить конкретное место в таблице                                                                      


Допустим, какой-то из пользователей захотел сменить страну, отправил через                                                                                                                    
форму запрос с новыми данными, которые нам нужно внести куда следует.                                                                                                                          


```sql
UPDATE user
SET country = 'Belarus'
WHERE id = 2;
```

# **DELETE**                                                                      

**Удаление записей из таблицы**                                                                      
Удаление записи из таблицы через **SQL** - очень простая операция.                                                                             
Всё, что нужно - это обозначить, что именно мы хотим удалить.                                                                      

```sql
DELETE FROM user
WHERE id = 4;
```

# Примечание: убедитесь, что используете **WHERE**, когда удаляете запись из таблицы.                                                                             
# Иначе вы удалите все записи из таблицы, сами того не желая.                                                                      

# **TRUNCATE**                                                                      

**Удаление таблиц**                                                                      

Если мы хотим удалить все данные из таблицы, но при этом оставить саму таблицу,                                                                             
нам следует использовать команду **TRUNCATE**:                                                                      

```sql
TRUNCATE TABLE table_name;
```

# **DROP**                                                                      

В случае, если мы хотим удалить саму таблицу, то нам следует использовать                                                                       
команду **DROP**:                                                                      

```sql
DROP TABLE table_name;
```

---

# **SQL Инъекции**                                                                      

**SQL-инъекция** — это атака, направленная на веб-приложение, в ходе которой                                                                           
конструируется **SQL-выражение** из пользовательского ввода путем простой                                                                             
**конкатенации** (например, **$query="SELECT * FROM users WHERE id="**. ...)                                                                             
В случае успеха атакующий может изменить логику выполнения **SQL-запроса**                                                                              
так, как это ему нужно                                                                      
