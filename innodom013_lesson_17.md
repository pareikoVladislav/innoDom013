<!-- TOC -->
* [**Algorithms**](#algorithms-)
* [**What is it - algorithms?**](#what-is-it---algorithms-)
* [**Tasks they can solve**](#tasks-they-can-solve-)
* [**Algorithms classification**](#algorithms-classification-)
* [**sorting algorithms**](#sorting-algorithms-)
* [**Main types of sorting algorithms**](#main-types-of-sorting-algorithms-)
* [**Commonly used sorting algorithms**](#commonly-used-sorting-algorithms-)
* [**Search algorithms**](#search-algorithms)
* [**The main types of search algorithms**](#the-main-types-of-search-algorithms-)
* [**Frequently used search algorithms**](#frequently-used-search-algorithms-)
* [**Working principles, pros, cons and asymptotic complexity of search algorithms**](#working-principles-pros-cons-and-asymptotic-complexity-of-search-algorithms-)
* [**Definition of the Big O**](#definition-of-the-big-o)
* [**How to calculate big O for an algorithm**](#how-to-calculate-big-o-for-an-algorithm-)
<!-- TOC -->

# **Algorithms**                                                        

# **What is it - algorithms?**                                                        

Алгоритм – это чётко определённая последовательность шагов или правил для                                                        
выполнения какой-либо задачи или решения проблемы. В контексте                                                         
программирования, алгоритмы – это серия инструкций, которые говорят                                                         
компьютеру, как выполнить определённую задачу.                                                        

**Примеры из повседневной жизни:**                                                                 

Алгоритмы окружают нас в повседневной жизни, даже если мы этого не                                                        
осознаём.                                                                                                                

Например, рецепт приготовления блюда – это алгоритм, где указаны шаги для                                                        
получения конечного результата. Или алгоритм сборки мебели из магазина:                                                         
последовательность шагов, которые нужно выполнить, чтобы собрать стол или шкаф.                                                        

# **Tasks they can solve**                                                        

**Алгоритмы могут решать множество различных задач. Например:**                                                        

* **Сортировка**: упорядочивание данных по определённому критерию, например,                                                        
сортировка чисел по возрастанию.                                                        

* **Поиск**: нахождение элемента в наборе данных, например, поиск конкретного                                                         
имени в списке.                                                        
* **Оптимизация**: нахождение наилучшего решения из всех возможных, например,                                                        
нахождение кратчайшего пути в графе.                                                        

**Краткий обзор применения в разных областях**: Алгоритмы находят применение                                                        
в самых разных областях, от информатики до инженерии, от финансов до биологии.                                                         
В информатике они используются для **обработки данных**, в машинном обучении –                                                         
**для анализа и прогнозирования данных**, в веб-разработке – для **улучшения                                                         
пользовательского опыта и оптимизации работы приложений.**                                                        

# **Algorithms classification**                                                        

**Алгоритмы можно классифицировать по различным критериям. Например:**                                                        

**По типу выполнения**:                                                         

* **итеративные** (использующие повторения)                                                        
* **рекурсивные** (вызывающие сами себя).                                                                      

**По способу решения задачи**:                                                         

* **алгоритмы сортировки** (например, быстрая сортировка)                                                        
* **алгоритмы поиска** (например, бинарный поиск)                                                        
* **алгоритмы оптимизации** (например, алгоритмы на основе жадных методов).                                                        


---

**Линейный поиск:** Это один из самых простых алгоритмов поиска.                                                         
Он заключается в последовательном просмотре каждого элемента в списке до тех                                                         
пор, пока не будет найден искомый элемент или список не закончится.                                                        


**Принцип работы:**                                                        

1) Начать с первого элемента массива или списка.                                                        
3) Сравнить каждый элемент с искомым значением.                                                        
4) Если элемент найден, вернуть его индекс.                                                        
5) Если достигнут конец списка и элемент не найден, вернуть индикатор                                                        
неудачи (например, -1).                                                        

```python
def linear_search(arr, x):
    for i in range(len(arr)):
        if arr[i] == x:
            return i
    return -1


# Пример использования
arr = [3, 5, 2, 4, 9]
x = 4
result = linear_search(arr, x)
print("Элемент найден на позиции: " + str(result))
```

**Нюансы и проблемы:**                                                        

**Производительность**: Основной недостаток линейного поиска – его скорость.                                                         
В худшем случае, когда искомый элемент отсутствует в массиве или находится в                                                         
его конце, алгоритму придётся проверить **каждый элемент**. Это делает линейный                                                        
поиск неэффективным для **больших массивов**.                                                        

**Простота реализации**: Преимущество линейного поиска заключается в его простоте.                                                         
Он легко реализуется, что делает его хорошим выбором для небольших массивов или в                                                         
ситуациях, когда массивы не упорядочены и другие, более быстрые алгоритмы поиска,                                                        
не применимы.                                                        

**Не требует предварительной обработки**: В отличие от бинарного поиска, линейный                                                         
поиск не требует предварительной сортировки данных, что может быть полезно, если                                                         
данные часто изменяются или сортировка данных занимает слишком много времени.                                                        

**Асимптотическая сложность**
**Временная сложность**: **Большое О** (`Big O`) линейного поиска – `O(n)`,                                                         
где `n` – количество элементов в массиве. Это означает, что в худшем случае                                                         
время выполнения алгоритма линейно увеличивается с увеличением                                                         
размера входных данных.                                                        

**Пространственная сложность**: Линейный поиск имеет пространственную                                                        
сложность `O(1)`, что означает, что он требует фиксированного количества                                                         
памяти, независимо от размера входных данных. Это делает его эффективным                                                         
с точки зрения использования памяти.                                                        

**Пример использования**
Линейный поиск часто используется в повседневных сценариях, например, при                                                         
поиске контакта в телефонной книге, которая не упорядочена по алфавиту,                                                         
или при поиске определённого продукта в небольшом списке покупок.                                                        

**В заключение**, **линейный поиск** – это простой, но медленный алгоритм для                                                         
больших наборов данных. Он наиболее эффективен в сценариях с небольшими                                                        
или неупорядоченными данными, где простота реализации и отсутствие                                                         
необходимости в предварительной обработке данных являются                                                         
ключевыми факторами.                                                        

---

# **sorting algorithms**                                                        

**Алгоритмы сортировки** – это методы упорядочивания элементов в списке                                                        
или массиве в определённом порядке (чаще всего по возрастанию или убыванию).                                                        

**Основная цель сортировки** – улучшить читаемость данных и упростить                                                         
последующие операции с данными, такие как поиск или слияние.                                                        

**Примеры использования в реальной разработке**:                                                        

Сортировка применяется во многих областях: от **организации данных в базах данных**                                                        
до **управления файлами в операционных системах**.                                                         

Например, сортировка используется для **упорядочивания результатов поиска                                                         
на веб-страницах**, **для обработки финансовых транзакций по дате или                                                         
сумме**, а также **в алгоритмах машинного обучения для упорядочивания                                                         
или оптимизации данных**.                                                        

# **Main types of sorting algorithms**                                                        

1) **Пузырьковая сортировка**: Это один из самых простых, но наименее                                                         
эффективных методов сортировки. Алгоритм работает, повторно проходя                                                         
через список, сравнивая соседние элементы и меняя их местами, если                                                         
они находятся в неправильном порядке.                                                        

```python
array_ = [2, 1, 4, 3, 7, 6, 7, 9, 443, 1, 0, 32, 213, 6, 4, 87, 9, 676, 87, 4, 32, 1]


def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]


bubble_sort(array_)

print(array_)
```

2) **Сортировка вставками:** Этот алгоритм берёт один элемент за другим                                                         
и вставляет его в правильное положение среди уже отсортированных                                                         
элементов. Эффективен для небольших данных или частично                                                        
отсортированных массивов.                                                        

```python
def insertion_sort(arr):
    # Цикл for начинается с 1, так как предполагается, что первый элемент уже отсортирован.
    for i in range(1, len(arr)):
        # 'key' содержит текущий элемент, который нужно вставить в отсортированную часть массива.
        key = arr[i]
        # 'j' - это индекс предыдущего элемента относительно 'key'.
        j = i - 1
        # Цикл while перемещает элементы, которые больше 'key', на одну позицию вперед.
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        # Вставляем 'key' на его правильное место в отсортированной части массива.
        arr[j + 1] = key


insertion_sort(array_)

print(array_)
```

3) **Быстрая сортировка:** Один из самых эффективных и широко используемых                                                         
алгоритмов. Он использует стратегию «разделяй и властвуй», разделяя массив                                                         
на подмассивы, которые затем сортируются независимо.                                                        

```python
array_ = [2, 1, 4, 3, 7, 6, 9, 443, 0, 32, 213, 676, 87]

def quick_sort(arr):
    # Базовый случай рекурсии: если массив пустой или содержит один элемент, возвращаем его как есть.
    if len(arr) <= 1:
        return arr

    # Выбор опорного элемента. Здесь выбирается элемент в середине массива.
    pivot = arr[len(arr) // 2]

    # Создание подмассива 'left', содержащего элементы меньше опорного элемента.
    left = [x for x in arr if x < pivot]

    # Создание подмассива 'middle', содержащего элементы, равные опорному элементу.
    middle = [x for x in arr if x == pivot]

    # Создание подмассива 'right', содержащего элементы больше опорного элемента.
    right = [x for x in arr if x > pivot]

    # Рекурсивный вызов функции quick_sort для сортировки подмассивов 'left' и 'right',
    # и их конкатенация с подмассивом 'middle'.
    return quick_sort(left) + middle + quick_sort(right)


sorted_array = quick_sort(array_)

print(sorted_array)
```

# **Commonly used sorting algorithms**                                                        

1) **Пузырьковая сортировка** (`Bubble Sort`)                                                        

* **Описание**: **Пузырьковая сортировка** – это простой алгоритм сортировки,                                                        
который многократно проходит по списку, сравнивает соседние элементы и меняет                                                         
их местами, если они находятся в неправильном порядке. Процесс повторяется                                                         
до тех пор, пока список не будет полностью отсортирован.                                                        

* **Применение**: Лучше всего подходит для небольших списков данных.                                                         
Из-за своей простоты часто используется в образовательных целях для                                                         
объяснения концепции сортировки.                                                        

* **Эффективность**: **Неэффективна для больших массивов данных**                                                         
из-за квадратичной временной сложности `O(n²)`.                                                        

2) **Сортировка вставками** (`Insertion Sort`)                                                        

* **Описание**: Сортировка вставками работает путём **последовательного                                                         
выбора каждого элемента** и **вставки его в правильное место среди                                                         
уже отсортированных элементов**.                                                        

* **Применение**: **Эффективна** для **небольших** или **частично                                                         
отсортированных массивов**.                                                        

* **Эффективность**: Обычно **более эффективна, чем пузырьковая                                                         
сортировка**, особенно для небольших списков, с временной сложностью                                                         
в худшем случае `O(n²)`.                                                        

3) **Быстрая сортировка** (`Quick Sort`)                                                        

* **Описание**: Быстрая сортировка – это **эффективный** алгоритм                                                         
сортировки, использующий стратегию **«разделяй и властвуй»**. Он выбирает                                                         
один элемент в качестве **опорного** и **разделяет** массив на две части:                                                        
**элементы меньше опорного** и **элементы больше опорного**, затем                                                         
рекурсивно применяет ту же стратегию к каждой части.                                                        

* **Применение**: Оптимальный выбор для больших массивов данных.                                                        

* **Эффективность**: **Один из самых быстрых алгоритмов** для общего                                                         
использования с ожидаемой временной сложностью `O(n log n)`, **но                                                         
требует осторожности** при выборе опорного элемента, чтобы избежать                                                         
худшего случая со сложностью `O(n²)`.                                                        

---

# **Search algorithms**

**Алгоритмы поиска** – это методы, используемые для поиска или                                                         
нахождения одного или нескольких элементов внутри коллекции данных,                                                         
такой как список, массив или другая структура данных.                                                        

Они могут использоваться для поиска данных в базе данных, нахождения                                                         
конкретного документа в большом архиве, поиска пути                                                         
в навигационных системах.                                                        

# **The main types of search algorithms**                                                        

**Линейный поиск:**                                                        

**Описание**: Проверяет каждый элемент в данных до тех пор, пока не                                                         
найдет искомый элемент или не достигнет конца данных.                                                        

```python
def linear_search(arr, x):
    for i in range(len(arr)):
        if arr[i] == x:
            return i
    return -1
```

**Бинарный поиск:**                                                        

**Описание**: Эффективный алгоритм поиска, который работает на принципе                                                        
деления пополам. Он предполагает, что данные отсортированы и делит их                                                        
на две части, выбирая средний элемент для сравнения с искомым значением.                                                        

**Бинарный поиск** эффективен и корректен **только** для **отсортированных                                                         
массивов**. Это связано с его принципом работы, который предполагает,                                                         
**что массив разделен на две части по значению элемента в середине**,                                                        
и **каждая часть имеет элементы, которые либо полностью меньше, либо                                                        
полностью больше этого среднего элемента**.                                                        

Если бинарный поиск применяется к неотсортированному массиву,                                                         
результаты будут **непредсказуемыми** и, скорее всего,                                                         
**некорректными**. Вот почему:                                                        

* **Неверные исключения:** Бинарный поиск исключает половину массива                                                         
на каждом шаге, **основываясь на предположении**, что массив отсортирован.                                                         
В **неотсортированном массиве** это предположение **неверно**, **и вы                                                        
можете исключить** часть массива, **которая содержит искомый элемент**.                                                        

* **Неверные сравнения**: Поскольку элементы не упорядочены, сравнение                                                        
искомого значения с элементом в середине массива не дает информации о                                                        
том, в какой части массива следует продолжить поиск.                                                        

```python
def binary_search(arr, x):
    # Устанавливаем начальные и конечные индексы массива
    low = 0
    high = len(arr) - 1
    mid = 0
    # Пока начальный индекс не превысит конечный
    while low <= high:
        # Находим середину массива
        mid = (high + low) // 2

        # Проверяем, находится ли искомый элемент в середине
        if arr[mid] < x:
            # Если элемент в середине меньше искомого, исключаем левую половину массива
            low = mid + 1
        elif arr[mid] > x:
            # Если элемент в середине больше искомого, исключаем правую половину массива
            high = mid - 1
        else:
            # Если элемент найден, возвращаем его индекс
            return mid
    # Если элемент не найден, возвращаем -1
    return -1

required_elem = binary_search(sorted_array, 87)

print(required_elem)
```

# **Frequently used search algorithms**                                                        

**Поиск в глубину** (`DFS – Depth-First Search`):                                                        

**Описание**: Алгоритм, который начинает поиск с корневого узла и                                                         
продвигается вглубь графа, насколько это возможно,                                                         
прежде чем отступать.                                                        

```python
def dfs(graph, node, visited):
    # Если текущий узел еще не был посещен
    if node not in visited:
        # Добавляем узел в множество посещенных
        print(node, end=" ")  # Выводим узел
        visited.add(node)

        # Перебираем всех соседей текущего узла
        for neighbour in graph[node]:
            # Рекурсивно вызываем функцию DFS для каждого соседа
            dfs(graph, neighbour, visited)


graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

visited = set()  # Пустое множество для отслеживания посещенных узлов

# Вызываем функцию DFS
dfs(graph, 'A', visited)
```

**В этом примере:**                                                        

* Граф `graph` представлен в виде словаря, где каждый ключ                                                         
соответствует узлу, а значения - это списки соседних узлов.
* Функция `dfs` вызывается с начальным узлом `A`.
* В процессе работы функции посещенные узлы добавляются в                                                         
множество `visited`, а также выводятся на экран.
* Рекурсивные вызовы функции `dfs` позволяют обойти весь                                                         
граф, исследуя каждую ветвь до конца, прежде чем отступать.                                                        

**Сценарии использования**: Решение головоломок, навигация в                                                        
играх, поиск компонентов связности в сети.                                                        


**Поиск в ширину** (`BFS – Breadth-First Search`):

**Описание**: Алгоритм начинает поиск с корневого узла и исследует                                                         
все соседние узлы на том же уровне, прежде чем двигаться на                                                         
следующий уровень графа.                                                        

```python
from collections import deque


def bfs(graph, start):
    # Множество для отслеживания посещенных узлов
    visited = set()
    # Создаем очередь и добавляем в нее начальный узел
    queue = deque([start])

    # пока есть очередь
    while queue:
        # Извлекаем узел из очереди
        vertex = queue.popleft()
        if vertex not in visited:
            print(vertex, end=" ")  # Выводим узел
            # Добавляем узел в множество посещенных
            visited.add(vertex)

            # Добавляем всех не посещенных соседей в очередь
            queue.extend(set(graph[vertex]) - visited)
    return visited


# Пример графа в виде словаря
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

# Вызываем функцию BFS
bfs(graph, 'A')
```

**В этом примере:**                                                        

* Граф `graph` представлен в виде словаря, где каждый ключ соответствует                                                         
узлу, а значения - это списки соседних узлов.
* Функция `bfs` начинает обход с узла `A`.
* В процессе работы функции узлы, которые нужно посетить, добавляются                                                         
в очередь `queue`.
* Каждый раз, когда узел извлекается из очереди, он проверяется на                                                         
предмет того, был ли он уже посещен. Если нет, он выводится на                                                         
экран и добавляется в множество посещенных узлов `visited`.
* Затем все соседние узлы, которые еще не были посещены,                                                         
добавляются в очередь.                                                        


**Сценарии использования**:                                                         
Алгоритмы маршрутизации, анализ уровня социальных сетей, поиск                                                         
кратчайшего пути в навигационных системах.                                                        
---

# **Working principles, pros, cons and asymptotic complexity of search algorithms**                                                        

1) **Линейный поиск**                                                        

* **Принцип работы**: Линейный поиск последовательно проверяет каждый                                                         
элемент в списке или массиве, начиная с первого и заканчивая последним,                                                         
до тех пор, пока не найдет искомый элемент или не достигнет конца списка.                                                        

* **Плюсы**: Простота реализации; не требует предварительной сортировки данных.                                                        

* **Минусы**: Неэффективен для больших массивов данных; время поиска                                                        
увеличивается пропорционально размеру данных.
* **Большое О**: Временная сложность – `O(n)`, где `n` – **количество                                                         
элементов в массиве**.                                                        


2) **Бинарный поиск**                                                        

**Принцип работы**: Бинарный поиск начинает с середины отсортированного                                                         
массива и сравнивает искомый элемент с этим средним элементом. Если                                                         
элементы не совпадают, алгоритм исключает половину элементов и                                                         
продолжает поиск в оставшейся половине, пока не найдет элемент                                                         
или не останется элементов для проверки.                                                        

**Плюсы**: Гораздо более эффективен, чем линейный поиск, особенно                                                         
для больших массивов.                                                        

**Минусы**: Требует предварительной сортировки массива; не                                                         
подходит для неупорядоченных или динамически изменяющихся массивов.                                                        

**Большое О**: Временная сложность – `O(log n)`, где `n` –                                                         
**количество элементов в массиве**.                                                        

3) **Поиск в глубину** (`DFS`)                                                        

**Принцип работы**: `DFS` начинает с корневого узла (или любого                                                        
другого узла) и исследует как можно дальше вдоль каждой ветви                                                         
перед отступлением. Это достигается за счет использования стека                                                        
для запоминания узлов, которые еще предстоит исследовать.                                                        

**Плюсы**: Меньше использует памяти по сравнению с `BFS`; хорошо                                                         
подходит для задач, где нужно исследовать все возможные пути или                                                         
найти решение, не обязательно являющееся кратчайшим.                                                        

**Минусы**: Может застрять в глубоких ветвях; не гарантирует                                                         
нахождение кратчайшего пути.                                                        

**Большое О**: Временная сложность – `O(V + E)`, где `V` –                                                         
**количество вершин**, а `E` – **количество ребер в графе**.                                                        

4) **Поиск в ширину** (`BFS`)                                                        

**Принцип работы**: `BFS` начинает с корневого узла и исследует все                                                         
соседние узлы на том же уровне, прежде чем двигаться на следующий уровень.                                                         
Это достигается за счет использования очереди для отслеживания                                                         
узлов для исследования.                                                        

**Плюсы**: Находит кратчайший путь в невзвешенных графах; более                                                        
систематический по сравнению с `DFS`.                                                        

**Минусы**: Может потребовать больше памяти, особенно на графах с                                                         
большой шириной.                                                        

**Большое О**: Временная сложность – `O(V + E)`, где `V` – **количество                                                        
вершин**, а `E` – **количество ребер в графе**.                                                        

---

# **Definition of the Big O**

**Что это такое, зачем нужно???**                                                        

**"Большое О"** (`Big O notation`) – это математическая нотация,                                                         
используемая для описания верхней границы сложности алгоритма.                                                         
Она показывает, как быстро может увеличиваться **время выполнения                                                         
алгоритма** или **затрачиваемая им память** в зависимости                                                         
от **размера входных данных**.                                                        

**Важность в алгоритмах**:                                                         
Эта нотация помогает разработчикам понять эффективность алгоритмов,                                                        
особенно при работе с большими объемами данных. Она позволяет                                                         
сравнивать алгоритмы и выбирать наиболее подходящий для                                                         
конкретной задачи, учитывая ограничения по времени и памяти.                                                        

# **How to calculate big O for an algorithm**                                                        

**Примеры расчета для различных алгоритмов:**                                                        

* Линейный поиск в массиве имеет сложность `O(n)`, где `n` – размер                                                        
массива, так как в худшем случае потребуется проверить каждый элемент.                                                        

* Бинарный поиск имеет сложность `O(log n)`, так как с каждым шагом                                                         
размер области поиска уменьшается вдвое.                                                        

**Визуализация сложности:** Графики сложности алгоритмов могут наглядно                                                        
показать, как меняется время выполнения или затрачиваемая память в                                                        
зависимости от размера входных данных.                                                        

**Сложность в худшем, среднем и лучшем случае:**

* **Худший случай** (`Worst Case`): Описывает максимальное                                                        
время выполнения или затраты памяти для алгоритма.                                                        
* **Средний случай** (`Average Case`): Описывает среднее                                                         
время выполнения или затраты памяти для алгоритма.                                                        
* **Лучший случай** (`Best Case`): Описывает минимальное                                                         
время выполнения или затраты памяти для алгоритма.                                                        


В контексте алгоритмов, `n` обычно обозначает **количество элементов**, над                                                        
которыми выполняется операция. Например, в алгоритме сортировки `n` может                                                        
быть **количеством элементов**, которые **нужно отсортировать**.                                                        

`log n` относится к логарифму числа `n`, обычно с основанием `2` (т.е.,                                                         
`log2 n`). В контексте алгоритмов, это часто связано с операциями,                                                        
которые делят данные на половины (или другие доли), такими как                                                         
**бинарный поиск**. Например, каждый раз, когда вы делите массив                                                        
пополам, чтобы найти элемент, это логарифмическая операция.                                                        

`O(n)`: Это означает, что время выполнения алгоритма увеличивается линейно                                                        
в зависимости от количества элементов `n`. Примером является **линейный поиск**,                                                         
где вам, **возможно**, придется просмотреть **каждый элемент**.                                                        

`O(n²)`: Здесь время выполнения увеличивается квадратично. Это типично для                                                        
алгоритмов, которые выполняют операции на каждой паре элементов,                                                         
например, сортировка пузырьком или вставками.                                                 

`O(log n)`: Алгоритмы с такой сложностью становятся немного медленнее                                                        
с увеличением `n`. **Бинарный поиск** - классический пример, где **каждый шаг**                                                        
**уменьшает размер поиска вдвое**.                                                        

`O(n log n)`: Это часто встречается в эффективных алгоритмах сортировки,                                                        
таких как **сортировка слиянием** или **быстрая сортировка**. Это означает, что                                                         
алгоритм выполняет `log n` операций для каждого из `n` элементов.                                                        

Как правило, `n` и `log n` используются для описания того, как изменяется сложность                                                        
алгоритма при увеличении размера входных данных. Чем меньше степень роста                                                         
функции сложности (например, `O(log n)` по сравнению с `O(n²)`), тем более                                                         
эффективным является алгоритм при больших объемах данных.                                                        


| **Алгоритм**             | **Лучший случай** | **Средний случай** | **Худший случай** |
|--------------------------|-------------------|--------------------|-------------------|
| **Поиск**                | -                 | -                  | -                 |
| Линейный поиск           | O(1)              | O(n)               | O(n)              |
| Бинарный поиск           | O(1)              | O(log n)           | O(log n)          |
| Поиск в глубину (DFS)    | -                 | O(V + E)           | O(V + E)          |
| Поиск в ширину (BFS)     | -                 | O(V + E)           | O(V + E)          |
| **Сортировка**           | -                 | -                  | -                 |
| Пузырьковая сортировка   | O(n)              | O(n ^ 2)           | O(n ^ 2)          |
| Сортировка вставками     | O(n)              | O(n ^ 2)           | O(n ^ 2)          |
| Быстрая сортировка       | O(n log n)        | O(n log n)         | O(n ^ 2)          |
| Сортировка слиянием      | O(n log n)        | O(n log n)         | O(n log n)        |
| Пирамидальная сортировка | O(n log n)        | O(n log n)         | O(n log n)        |

**Объяснения:**                                                        

* `V` обозначает количество вершин в графе, а `E` - количество ребер.                                                        
* `В` контексте графов (`DFS` и `BFS`), сложность зависит от структуры графа.                                                        

Для алгоритмов сортировки, "лучший случай" часто соответствует ситуации,                                                        
когда данные уже частично упорядочены. "Средний случай" и "худший случай"                                                         
могут сильно различаться в зависимости от конкретной                                                         
реализации алгоритма и входных данных.                                                                                                                                     
